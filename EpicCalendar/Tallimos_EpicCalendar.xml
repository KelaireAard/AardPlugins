<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Monday, November 23, 2020, 12:40 PM -->
<!-- MuClient version 5.07-pre -->

<!-- Plugin "Tallimos_EpicCalendar" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Tallimos_EpicCalendar"
   author="Tallimos"
   id="1d1e01d90f0e2983c358b32e"
   language="Lua"
   purpose="Allows the user to store upcoming epic run dates and allows for an automated way of telling people"
   save_state="y"
   date_written="2020-11-23 12:39:41"
   requires="4.36"
   version="1.71"
   >
   
</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->


<triggers>
	<trigger
		group="NoteUpdate"
		match="^Current forum changed to Epics\. You can read and write in this forum\."
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdate"
		match="^To\s+\:\s(\w+)"
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdateLine1"
		match="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdateLine2"
		script="NoteUpdateEnableEnd"
		match="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdateNoteContent"
		match="(.*?)"
		sequence="200"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="NoteUpdateEnd"
		match="~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
		script="NoteUpdateEnd"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdate"
		script="NoteUpdateSubject"
		match="^From\s+\:\s(\w+)\:\s(.*)"
		sequence="110"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdate"
		script="NoteUpdateNoteNum"
		match="^Forum\s+\:\s(\w+)\s\-\s\#(\d+)"
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="NoteUpdate"
		script="NoteUpdateNoteDate"
		match="^Date\s+\:\s(\w+)\s(\w+)\s+(\d+)\s+(\d+)\:(\d+)\:(\d+)\s(\d+)"
		sequence="100"
		ignore_case="y"
		regexp="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="You can only read posts in this forum."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetBoardEndTrig"
		script="GetBoardEnd"
		match="^Current forum changed to (\w+)\. You can read and write in this forum\."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="GetBoardEndTrig"
		script="GetBoardEnd"
		match="^Current forum changed to (\w+)\. You can only read in this forum\."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="(.*?)"
		sequence="300"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		script="CurrentBoard"
		match="^Your current forum is (\w+)\."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="You have no unread notes in any subscribed forum."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="You can read and write posts in this forum."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="Use 'forums all' to see subscribed forums."
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="Use 'subscribe' to see all forums and which you are subscribed to."
		sequence="110"
		script="EndGetCurrentBoard"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="+-------+------------+-----------+---------------------------------+"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="\|\sForum\s\|\sName\s+\|\sNew Posts\s\|\sDescription\s+\|"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="GetCurrentBoardTrig"
		match="\|\s+(\d+)\s\|\s+(\w+)\s\|\s+(\d+)\s\|\s(.*?)\s+\|"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="BotCommandCapture"
		match="^(\w+)\stells\syou\s\'\!(help|noteremove|listday|listepic|nextepic|nextday|nextleader)\s?(\w+)?\'$"
		name="TellChannel"
		script="TellChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="BotCommandCapture"
		match="^You tell the CLAN\:\s\'(?:.*?)?\s?\!(help|noteremove|listday|listepic|nextepic|nextday|nextleader)\s?(\w+)?\'$"
		name="ClanChannelYou"
		script="ClanChannelYou"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="BotCommandCapture"
		match="^\(Group\)\s(\w+)\:\s\'\!(help|noteremove|listday|listepic|nextepic|nextday|nextleader)\s?(\w+)?\'$"
		name="GroupChannel"
		script="GroupChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="BotCommandCapture"
		match="^\(Friend\)\s(\w+)\:\s\'\!(help|noteremove|listday|listepic|nextepic|nextday|nextleader)\s?(\w+)?\'$"
		name="FriendChannel"
		script="FriendChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>
	<trigger
		group="BotCommandCapture"
		match="^You tell your friends\:\s\'(?:.*?)?\s?\!(help|noteremove|listday|listepic|nextepic|nextday|nextleader)\s?(\w+)?\'$"
		name="FriendChannelYou"
		script="FriendChannelYou"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>	
	<trigger
		group="BotCommandCapture"
		match="^(\w+)\s\((?:\w+)\)\stells the CLAN\:\s\'(?:.*?)?\s?\!(help|noteremove|listday|listepic|nextepic|nextday|nextleader)\s?(\w+)?\'$"
		name="ClanChannel"
		script="ClanChannel"
		sequence="100"
		regexp="y"
		ignore_case="y"
		>
	</trigger>	
	<trigger
		group="SystemTime"
		match="^\s+\*\sAardwolf last restarted on\s\:\s+(\d+)\:(\d+)\:(\d+)\s\-\s(.*?)"
		sequence="100"
		regexp="y"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="SystemTime"
		script="GetSystemTimeTrig"
		match="^\s+\*\sThe system time is\s+\:\s+(\d+)\:(\d+)\:(\d+)\s\-\s(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s(\d+)\s(\w+)\,\s(\d+)"
		sequence="100"
		regexp="y"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="EpicCalendar"
		match="(.*?)"
		sequence="300"
		ignore_case="y"
		omit_from_output="y"
		regexp="y"
		>
	</trigger>
	<trigger
		group="EpicUpdateEnd"
		match="+------+------------+-------------+-------------------------------------+----+"
		script="EpicUpdateEnd"
		name="EpicUpdateEnd"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="EpicCalendar"
		match="+------+------------+-------------+-------------------------------------+----+"
		sequence="110"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="EpicCalendar"
		match="Posts in the Epics forum :"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="EpicCalendar"
		match="Current forum changed to Epics. You can read and write in this forum."
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		group="EpicCalendar"
		match="^\|\sPost\#\|\sDate/Time\s+\|\sAuthor\s+\|\sSubject\s+\|\Size\|$"
		sequence="100"
		regexp="y"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
	<trigger
		match="^INFO\:\sNew\spost\s\#(\d+)\sin\sforum\sEpics\sfrom\s(\w+)\sSubj\:\s(.*?)"
		regexp="y"
		script="EpicNote"
		sequence="100"
		ignore_case="y"
		enabled="y"
		>
	</trigger>
	<trigger
		group="EpicCalendar"
		match="^\|?\s+(\d+)\|(.*?)\|(?:\*|\s)(\w+)\s+\|\s(.*)(?:\s+)?\|\s+(\d+)\|$"
		regexp="y"
		script="EpicBoard"
		sequence="100"
		ignore_case="y"
		omit_from_output="y"
		>
	</trigger>
</triggers>

<!--  Timers  -->

<timers>
	<timer
		name="clandelay" 
		second="5"  
		enabled="n"
		script="ClanDelayDisable"
		>
	</timer>
	<timer
		name="gtdelay" 
		second="5"
		enabled="n"
		script="GroupTellDelayDisable"
		>
	</timer>
	<timer
		name="ftdelay" 
		second="5" 
		enabled="n"
		script="FriendTalkDelayDisable"
		>
	</timer>
	<timer
		name="telldelay" 
		second="5" 
		enabled="n"
		script="TellDelayDisable"
		>
	</timer>
	<timer
		name="HourlyNextEpicSilent" 
		hour="1"   
		enabled="n"
		script="HourlyNextEpicSilent"
		>
	</timer>
	<timer
		name="NextEpicComingUp" 
		hour="1" 
		enabled="n"
		script="NextEpicComingUp"
		>
	</timer>
	<timer
		name="NextEpic5Minutes" 
		minute="1" 
		enabled="n"
		script="NextEpic5Minutes"
		>
	</timer>
	<timer
		name="HourlyNextEpicNotification" 
		hour="1"  
		enabled="n"
		script="HourlyNextEpicNotification"
		>
	</timer>

</timers>

<!--  Aliases  -->

<aliases>
	<alias
		script="CommandMenu"
		match="^(?:ecal|epiccal|epiccalendar) (.*?)$"
		enabled="y"
		ignore_case="y"
		regexp="y"
		sequence="100"
		>
	</alias>
</aliases>

<script>
<![CDATA[
-- Helpers Quadrapus, Hader, Fiendish, Areia
require "tprint"
require "mw_theme_base"
require "serialize"
require "commas"
require "gmcphelper"
require "copytable"
require "aardmapper"
require "aard_lua_extras"
require "wait"
require "async"

local remain_colour   = "lime"
local time_colour     = "lightslategrey"
local day_colour      = "lightslategrey"
local leader_colour   = "yellow"
local epic_colour     = "red"
local msg_colour      = "lightslategrey"
local err_colour      = "firebrick"
local help_colour     = "lightslategrey"
local qty_colour      = "cyan"
local optional_colour = "lightcoral"
local command_colour  = "white"
local cmd_required    = "royalblue"
local help_command_colour  = "red"

local noteline = "=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-="
NextEpicNotification = 0
ran = false

	EpicLeaders = {
		[1] = "kers",
		[2] = "shaelynne",
		[3] = "hazeknight",
		[4] = "roume",
	}
		
	SystemTimeTable = {
      month = 0,
      wday = 0,
      yday = 0,
      day = 0,
      min = 0,
      isdst = false,
      sec = 0,
      hour = 0,
      year = 0,
    }

	Helpers = {
		[1] = "Quadrapus",
		[2] = "Hadar",
		[3] = "Fiendish",
	}
		
	EpicMobs = {
		[1] = "alai",
		[2] = "orbury",
	}
	
	DaysofWeek = {
		[1] = "sunday",
		[2] = "monday",
		[3] = "tuesday",
		[4] = "wednesday",
		[5] = "thursday",
		[6] = "friday",
		[7] = "saturday",
	}

	DaysofWeekShort = {
		[1] = "sun",
		[2] = "mon",
		[3] = "tue",
		[4] = "wed",
		[5] = "thu",
		[6] = "fri",
		[7] = "sat",
	}

	MonthMaxDays = {
		[1] = 31,
		[2] = 28,
		[3] = 31,
		[4] = 30,
		[5] = 31,
		[6] = 30,
		[7] = 31,
		[8] = 31,
		[9] = 30,
		[10] = 31,
		[11] = 30,
		[12] = 31,
	}
	
	Months = {
		[1] = "jan",
		[2] = "feb",
		[3] = "mar",
		[4] = "apr",
		[5] = "may",
		[6] = "jun",
		[7] = "jul",
		[8] = "aug",
		[9] = "sep",
		[10] = "oct",
		[11] = "nov",
		[12] = "dec",
	}

	MonthsYDay = {
		[1] = 0,
		[2] = 31,
		[3] = 59,
		[4] = 90,
		[5] = 120,
		[6] = 151,
		[7] = 181,
		[8] = 212,
		[9] = 242,
		[10] = 273,
		[11] = 304,
		[12] = 334,
	}

	EpicNames = {
		[1] = "genie",
		[2] = "icefall1",
		[3] = "icefall2",
		[4] = "inferno",
		[5] = "oc",
		[6] = "winds",
		[7] = "terra",
		[8] = "titan",
		[9] = "icefall",
		[10] = "if1",
		[11] = "if2",
		[12] = "oldvanir",
		[13] = "testmaze10",
		[14] = "transcendence", 
	}

	-- Borrowed for SnD
	AreaNames = {
		-- A --
		["aardington"] = "Aardington Estate",
		["academy"] = "Academy",
		["adaldar"] = "Battlefields of Adaldar",
		["afterglow"] = "Afterglow",
		["agroth"] = "Marshlands of Agroth",
		["ahner"] = "Kingdom of Ahner",
		["alehouse"] = "Wayward Alehouse",
		["amazon"] = "Amazon Nation",
		["amusement"] = "Amusement Park",
		["andarin"] = "Blighted Tundra of Andarin",
		["annwn"] = "Annwn",
		["anthrox"] = "Anthrox",
		["arena"] = "Gladiator's Arena",
		["arisian"] = "Arisian Realm",
		["ascent"] = "First Ascent",
		["astral"] = "Astral Travels",
		["atlantis"] = "Atlantis",
		["autumn"] = "Eternal Autumn",
		["avian"] = "Avian Kingdom",
		["aylor"] = "Grand City Aylor",
		-- B --
		["badtrip"] = "Bad Trip",
		["bazaar"] = "Onyx Bazaar",
		["beer"] = "Land of Beer Goblins",
		["believer"] = "Path of the Believer",
		["blackrose"] = "Black Rose",
		["bliss"] = "Wedded Bliss",
		-- C --
		["caldera"] = "Icy Caldera Mauldoon",
		["callhero"] = "Call of Heroes",
		["camps"] = "Tournament Camps",
		["canyon"] = "Canyon Memorial Hospital",
		["caravan"] = "Gypsy Caravan",
		["cards"] = "House of Cards",
		["carnivale"] = "Olde Worlde Carnivale",
		["cataclysm"] = "Cataclysm",
		["cathedral"] = "Old Cathedral",
		["cats"] = "Sheila's Cat Sanctuary",
		["chasm"] = "Chasm and Catacombs",
		["chessboard"] = "Chessboard",
		["childsplay"] = "Child's Play",
		["cineko"] = "Aerial City of Cineko",
		["citadel"] = "Flying Citadel",
		["conflict"] = "Thandeld's Conflict",
		["coral"] = "Coral Kingdom",
		["cougarian"] = "Cougarian Queendom",
		["cove"] = "Kiksaadi Cove",
		["cradle"] = "Cradlebrook",
		["crynn"] = "Crynn's Church",
		-- D --
		["damned"] = "Halls of the Damned",
		["darklight"] = "Darklight",
		["darkside"] = "Darkside Fractured Lands",
		["ddoom"] = "Desert Doom",
		["deadlights"] = "Deadlights",
		["deathtrap"] = "Deathtrap Dungeon",
		["deneria"] = "Realm of Deneria",
		["desert"] = "Desert Prison",
		["desolation"] = "Mountains of Desolation",
		["dhalgora"] = "Dhal'Gora Outlands",
		["diatz"] = "Three Pillars Diatz",	
		["diner"] = "Tumari's Diner",
		["dortmund"] = "Dortmund",
		["drageran"] = "Drageran Empire",
		["dread"] = "Dread Tower",
		["dsr"] = "Diamond Soul Revelation",
		["dundoom"] = "Dungeon Doom",
		["dunoir"] = "Mount DuNoir",
		["duskvalley"] = "Dusk Valley",
		["dynasty"] = "Eighteenth 18th Dynasty",
		-- E --
		["earthlords"] = "Earth Lords",
		["earthplane"] = "Earth Plane 4",
		["elemental"] = "Elemental Chaos",
		["empire"] = "Empire of Aiighialla",
		["empyrean"] = "Empyrean Streets of Downfall",
		["entropy"] = "Archipelago Entropy",
		-- F --
		["fantasy"] = "Fantasy Fields",
		["farm"] = "Kimr's Farm",
		["fayke"] = "All in Fayke Day",
		["fens"] = "Curse Midnight Fens",
		["fields"] = "Killing Fields",
		["firebird"] = "Realm of the Firebird",
		["firenation"] = "Realm of the Sacred Flame",
		["fireswamp"] = "Fire Swamp",
		["fortress"] = "Goblin Fortress",
		["fractured"] = "Fractured Lands",
		["ft1"] = "Faerie Tales",
		["ftii"] = "Faerie Tales II FT2",
		-- G --
		["gallows"] = "Gallows Hill",
		["gathering"] = "Gathering Horde",
		["gauntlet"] = "Gauntlet",
		["genie"] = "Genie's Last Wish",
		["gilda"] = "Gilda and the Dragon",
		["glamdursil"] = "Glamdursil",
		["glimmerdim"] = "Brightsea Glimmerdim",
		["gnomalin"] = "Cloud City of Gnomalin",
		["goldrush"] = "Gold Rush",
		["graveyard"] = "Graveyard",
		["greece"] = "Ancient Greece",
		["gwillim"] = "Trouble with Gwillimberry",
		-- H --
		["hatchling"] = "Hatchling Aerie",
		["hawklord"] = "Realm of the Hawklords",
		["hedge"] = "Hedgehog's",
		["helegear"] = "Helegear Sea",
		["hell"] = "Descent to Hell",
		["hoard"] = "Swordbreaker's Hoard",
		["hodgepodge"] = "Magical Hodgepodge",
		["horath"] = "Broken Halls of Horath",
		["horizon"] = "Nebulous Horizon",
		-- I --
		["icefall"] = "Icefall",
		["illoria"] = "Illoria",
		["imagi"] = "Imagi's Nation",
		["imperial"] = "Imperial Nation",
		["infamy"] = "Realm of Infamy",
		["inferno"] = "Journey to the Inferno",
		["infest"] = "Infestation",
		["insan"] = "Insanitaria",
		-- J --
		["jenny"] = "Jenny's Tavern",
		["jotun"] = "Jotunheim",
		-- K --
		["kearvek"] = "Keep of Kearvek",
		["kerofk"] = "Kerofk",
		["ketu"] = "Ketu Uplands",
		["kingsholm"] = "Kingsholm",
		["knossos"] = "Great City of Knossos",
		["kobaloi"] = "Keep of the Kobaloi",
		["kultiras"] = "Kul Tiras",
		-- L --
		["lab"] = "Chaprenula's Laboratory",
		["labyrinth"] = "Labyrinth",
		["lagoon"] = "Black Lagoon",
		["landofoz"] = "Land of Oz",
		["laym"] = "Tai'rha Laym",
		["legend"] = "Land of Legend LoL",
		["lemdagor"] = "Storm Ships of Lem-Dagor",
		["lidnesh"] = "Forest of Li'Dnesh",
		["livingmine"] = "Living Mines of Dak'Tai",
		["longnight"] = "Into the Long Night",
		["losttime"] = "Island of Lost Time",
		["lplanes"] = "Lower Planes",
		-- M --
		["maelstrom"] = "Maelstrom",
		["manor"] = "Death's Manor",
		["masq"] = "Masquerade Island",
		["mayhem"] = "Artificer's Mayhem",
		["melody"] = "Art of Melody",
		["minos"] = "Shadows of Minos",
		["mistridge"] = "Covenant of Mistridge",
		["monastery"] = "Monastery",
		["mudwog"] = "Mudwog's Swamp",
		-- N --
		["nanjiki"] = "Nanjiki Ruins",
		["necro"] = "Necromancer's Guild",
		["nenukon"] = "Nenukon and the Far Country",
		["newthalos"] = "New Thalos",
		["northstar"] = "Northstar",
		["nottingham"] = "Nottingham",
		["nulan"] = "Plains of Nulan'Boar",
		["nursing"] = "Ascension Bluff Nursing Home",
		["nynewoods"] = "Nyne Woods",
		-- O --
		["oc"] = "Oradrin's Chosen",
		["oceanpark"] = "Ocean Adventure Park",
		["omentor"] = "Witches of Omen Tor",
		["origins"] = "Tribal Origins",
		["orlando"] = "Hotel Orlando",
		-- P --
		["paradise"] = "Paradise Lost",
		["peninsula"] = "Tairayden Peninsula",
		["petstore"] = "Giant's Pet Store",
		["pompeii"] = "Pompeii",
		["promises"] = "Foolish Promises",
		["prosper"] = "Prosper's Island",
		-- Q --
		["qong"] = "Qong",
		["quarry"] = "Gnoll's Quarry",
		-- R --		
		["radiance"] = "Radiance Woods",
		["raga"] = "Raganatittu",
		["raukora"] = "Blood Opal of Rauko'ra",
		["rebellion"] = "Rebellion Nix",
		["remcon"] = "Reman Conspiracy",
		["reme"] = "City of Reme",
		["rosewood"] = "Rosewood Castle",
		["ruins"] = "Ruins of Diamond Reach",
		-- S --
		["sagewood"] = "Sagewood Grove",
		["sahuagin"] = "Abyssal Caverns of Sahuagin",
		["salt"] = "Great Salt Flats",
		["sanctity"] = "Sanctity of Eternal Damnation",
		["sanctum"] = "The Blood Sanctum",
		["sandcastle"] = "Sho'aram Shoaram Castle in the Sand",
		["sanguine"] = "Sanguine Tavern",
		["scarred"] = "Scarred Lands",
		["sendhian"] = "Adventures in Sendhia",
		["sennarre"] = "Sen'narre Lake",
		["shouggoth"] = "Temple of Shouggoth",
		["siege"] = "Kobold Seige Camp KSC",
		["sirens"] = "Siren's Oasis Resort",
		["slaughter"] = "Slaughterhouse",
		["snuckles"] = "Snuckles Village",
		["soh"] = "School of Horror SOH1",
		["sohtwo"] = "School of Horror SOH2",
		["solan"] = "Town of Solan",
		["songpalace"] = "Palace of Song",
		["spyreknow"] = "Guardian's Spyre of Knowledge",
		["stone"] = "Fabled City of Stone",
		["storm"] = "Storm Mountain",
		["stormhaven"] = "Ruins of Stormhaven",
		["stronghold"] = "Dark Elf Stronghold DES",
		["stuff"] = "Stuff of Shadows",
		-- T --
		["takeda"] = "Takeda's Warcamp",
		["talsa"] = "Empire of Talsa",
		["temple"] = "Temple of Shal'indrael",
		["tanra"] = "Tanra'vea",
		["terra"] = "Cracks of Terra",
		["terramire"] = "Fort Terramire",
		["thieves"] = "Den of Thieves",
		["times"] = "Intrigues of Times Past",
		["tirna"] = "Tir na Nog",
		["titan"] = "Titans' Keep",
		["tol"] = "Tree of Life",
		["tombs"] = "Relinquished Tombs",
		-- U --
		["umari"] = "Umari's Castle",
		["underdark"] = "Underdark",
		["uplanes"] = "Upper Planes",
		["uprising"] = "Uprising",
		-- V --
		["vale"] = "Sundered Vale",
		["verdure"] = "Verdure Estate",
		["verume"] = "Jungles of Verume",
		["village"] = "Peaceful Giant Village",
		["vlad"] = "Vlad Shamir",
		["volcano"] = "Silver Volcano",
		-- W --
		["weather"] = "Weather Observatory",
		["werewood"] = "Were Wood",
		["wildwood"] = "Wildwood",
		["winds"] = "Winds of Fate",
		["winter"] = "Winterlands",
		["wizards"] = "War of the Wizards WoW",
		["wonders"] = "Seven Wonders",
		["wooble"] = "Wobbly Woes of Woobleville",
		["woodelves"] = "Wood Elves of Nalondir",
		["wtc"] = "Warrior Training Camp WTC",
		["wyrm"] = "Council of the Wyrm",
		-- X --
		["xmas"] = "Christmas Vacation",
		["xylmos"] = "Xyl's Mosaic",
		-- Y --
		["yarr"] = "Misty Shores of Yarr",
		["ygg"] = "Yggdrasil: The World Tree",
		["yurgach"] = "Yurgach Domain",
		-- Z --
		["zangar"] = "Zangar's Demonic Grotto",
		["zodiac"] = "Realm of the Zodiac",
		["zoo"] = "Aardwolf Zoological Park",
		["zyian"] = "Dark Temple of Zyian",
	}

--------------------------------------------
--------------- COMMAND MENU ---------------
--------------------------------------------
function CommandMenu(name, line, wc)
	commandline = trim(string.lower(wc[1]))
	wordtable = utils.split (commandline, " ")

	cmd = wordtable[1]
	
	if cmd == "clear" then
		ClearEpicTable()
	elseif cmd == "update" then
		-- update_plugin()
		--dbot.version.update.release(drlDbotUpdateInstall, endTag)
		ecal_update()
		EpicMisc["Updating"] = "YES"
	elseif cmd == "changelog" then
		dbot.print("@DFull changelog:")
		dbot.version.changelog.get(0, endTag) -- show changelog from version 0 to the latest
	elseif cmd == "checkversion" then
		dbot.version.update.release(drlDbotUpdateCheck, endTag)
	elseif cmd == "reset" then
		ResetEpicTable()
		rcheck = "YES"
	elseif cmd == "nupdate" then
		nnum = wordtable[2]
		
		if tonumber(nnum) ~= nil then
			NoteUpdate(nnum)
		else
			ColourNote(msg_colour, "", "Please enter a note number to check")
		end
	elseif cmd == "list" then
		EpicList()
	elseif cmd == "search" then
		epicname = wordtable[2]
		SearchEpic(epicname)
	elseif cmd == "nextepic" or cmd == "next" then
		if wordtable[2] == nil then
			attrib = nil
			channel = nil
			GetNextEpic(attrib, channel)
		else
			attrib = wordtable[2]
		
			if attrib == "epic" then
				if wordtable[3] == nil then
					channel = nil
					GetNextEpic(attrib, channel)
				else
					channel = wordtable[3]
					if channel == "tell" then channel = channel .. " " .. wordtable[4] end
					
					GetNextEpic(attrib, channel) 
				end
			elseif attrib == "help" then
				EpicCalendarHelpNext()
			else
				if wordtable[3] == nil then
					channel = nil
					GetNextEpic(attrib, channel)
				else
					channel = wordtable[3]
					
					if channel == "tell" then channel = channel .. " " .. wordtable[4] end
					
					GetNextEpic(attrib, channel)
				end
			end
		end
	elseif cmd == "nextleader" then
		leader = wordtable[2]
		channel = wordtable[3]
		
		if channel == "tell" then channel = channel .. " " .. wordtable[4] end
		
		GetNextEpicLeader(leader, channel)
	elseif cmd == "nextday" then
		day = wordtable[2]
		channel = wordtable[3]
		
		if channel == "tell" then channel = channel .. " " .. wordtable[4] end
		
		GetNextEpicDay(day, channel)
	elseif cmd == "bot" then
		attrib = wordtable[2]

		if attrib == "enable" then
			EnableBot()
		elseif attrib == "disable" then
			DisableBot()
		elseif attrib == "help" then
			EpicCalendarHelpBot()
		elseif attrib == "add" then
			user = wordtable[3]
			
			if user == "room" then
				NoteRoom(attrib)
			elseif user ~= nil then
				UserPermission(attrib, user)
			else
				ColourNote(msg_colour, "", "Command usage ", qty_colour, "", "ecal bot add <user name>", msg_colour, "", ".")
			end
		elseif attrib == "remove" then
			user = wordtable[3]

			if user == "room" then
				NoteRoom(attrib)
			elseif user ~= nil then
				UserPermission(attrib, user)
			else
				ColourNote(msg_colour, "", "Command usage ", qty_colour, "", "ecal bot remove <user name>", msg_colour, "", ".")
			end
		elseif attrib == "permissions" then
			TogglePermissions()
		elseif attrib == "plist" then
			ListPermissions()
		elseif attrib == "list" then
			if wordtable[3] == "room" then
				ListRooms()
			end
		elseif attrib == "auto" then
			sub = wordtable[3]
			
			if sub == "add" then
				channel = wordtable[4]
				AutoAddRemoveChannel(sub, channel)
			elseif sub == "remove" then
				channel = wordtable[4]
				AutoAddRemoveChannel(sub, channel)
			elseif sub == "list" then
				ListChannels(attrib)
			elseif sub == "enable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]
					
					if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
						ColourNote(qty_colour, "", channel, msg_colour, "", " has not been be added to the auto notification list")
					else
						ColourNote(msg_colour, "", "Automatic notifications for ", qty_colour, "", channel, msg_colour, "", " has been enabled.")
						EpicMisc["NotificationBot"]["Auto"][channel] = true
					end
				else
					EpicMisc["NotificationBot"]["AutoEnabled"] = true
					
					EnableAutoBot()
				end
			elseif sub == "disable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]
					
					if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
						ColourNote(qty_colour, "", channel, msg_colour, "", " has not been be added to the auto notification list")
					else
						ColourNote(msg_colour, "", "Automatic notifications for ", qty_colour, "", channel, msg_colour, "", " has been disabled.")
						EpicMisc["NotificationBot"]["Auto"][channel] = false
					end
				else
					EpicMisc["NotificationBot"]["AutoEnabled"] = false

					DisableAutoBot()
				end
			end
		elseif attrib == "commands" then
			sub = wordtable[3]
			
			if sub == "list" then
				ListChannels(attrib)
			elseif sub == "enable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]

					if EpicMisc["NotificationBot"]["Commands"][channel] == nil then
						ColourNote(qty_colour, "", channel, msg_colour, "", " has not been be added to the command channel notification list")
					else
						ColourNote(msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " have been enabled.")
						EpicMisc["NotificationBot"]["Commands"][channel] = true
					end
				else
					EpicMisc["NotificationBot"]["CommandsEnabled"] = true

					EnableCommandBot()
				end
			elseif sub == "disable" then
				if wordtable[4] ~= nil then
					channel = wordtable[4]
				
					if EpicMisc["NotificationBot"]["Commands"][channel] == nil then
						ColourNote(qty_colour, "", channel, msg_colour, "", " has not been be added to the command channel notification list")
					else
						ColourNote(msg_colour, "", "Channel commands for ", qty_colour, "", channel, msg_colour, "", " have been disabled.")
						EpicMisc["NotificationBot"]["Commands"][channel] = false
					end
				else
					EpicMisc["NotificationBot"]["CommandsEnabled"] = false
				
					DisableCommandBot()
				end
			end
		elseif attrib == "warning" then
			sub = wordtable[3]
			
			if sub == "enable" then
				EpicMisc["NotificationBot"]["Warning"]["Enabled"] = true

				EnableWarningBot()
			elseif sub == "disable" then
				EpicMisc["NotificationBot"]["Warning"]["Enabled"] = false
			
				DisableWarningBot()
			end
		else
			ColourNote(msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help bot", msg_colour, "", " for more information.")
		end
	elseif cmd == "help" then
		if wordtable[2] == nil then
			EpicCalendarHelp()
		else
			attrib = wordtable[2]
			
			if attrib == "bot" then
				EpicCalendarHelpBot()
			elseif attrib == "next" then
				EpicCalendarHelpNext()
			else
				ColourNote(msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
			end
		end
	else		
		ColourNote(msg_colour, "", "Invalid command. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
	end
	
	SaveState()
end -- CommandMenu
	
---------------------------------------------
-------------- CHECK FUNCTIONS --------------
---------------------------------------------
function CheckRoom()
	GetRoom()
	
	rcheck = "no"
	
	for i, v in pairs(EpicMisc["NoteRooms"]) do
		if i == gmcproomid then
			rcheck = "yes"
		end	
	end

	return rcheck
end -- CheckRoom

function CheckPermission(CheckName)
    local name = string.lower(CheckName)
	pcheck = "no"
	
	GetCharName()
	
	if name == charname then
		pcheck = "yes"
		return pcheck
	end
	
	for i, v in pairs(EpicPermissionTable) do
		if i == name then
			pcheck = "yes"
		end	
	end
	
	return pcheck
end -- CheckPermission

function CheckEpic(echeck, subjectline)
    local words = string.split(subjectline," ")
    
    for i,v in pairs(words) do
        if echeck == v then return v end
    end
    return nil
end -- CheckEpic

function CheckLowest(index)
	if CheckOver(index) == "NO" then
		ReturnType = "table"
		ttable = EpicTimeDifference(index, ReturnType)

		if ttable ~= nil then 
			seconds = TimeToSeconds(ttable)
		end

		if seconds ~= nil then
			if seconds < lowestseconds then 
				lowestseconds = seconds
				lowestindex = index
			end
		end
	end
end -- CheckLowest

function CheckMob(CheckName)
    local name = string.lower(CheckName)
	mcheck = "no"
	
    for i, v in ipairs(EpicMobs) do
		if v == name then
			mcheck = "yes"
		end	
	end
	return mcheck
end -- CheckMob

---------------------------------------------
-------- GET CURRENT BOARD FUNCTIONS --------
---------------------------------------------
function GetCurrentBoard()
	world.EnableGroup ("GetCurrentBoardTrig", 1)
	SendNoEcho ("board")
end -- GetCurrentBoard

function CurrentBoard(name, line, wc)
	cboard = wc[1]
end

function EndGetCurrentBoard()
	world.EnableGroup ("GetCurrentBoardTrig", 0)
end

function GetBoardEnd()
	world.EnableGroup ("GetBoardEndTrig", 0)
end

---------------------------------------------
--------- MAIN EPIC TABLE FUNCTIONS ---------
---------------------------------------------
function ClearEpicTable()
	EpicTable = {}
	TableIndex = 0
	
	ColourNote(msg_colour, "", "Epic Run list has been cleared.")
	SaveState()	
end -- ClearEpicTable

function UpdateEpicTable()
	listtype = "none"
	GetSystemTime()

	world.EnableGroup ("EpicCalendar", 1)
	SendNoEcho ("board epics")
	SendNoEcho ("note list")
end -- UpdateEpicTable

function ResetEpicTable()
	listtype = "none"
	GetSystemTime()
	
	EpicTable = {}
	TableIndex = 0
	
	GetCurrentBoard()
	
	world.EnableGroup ("EpicCalendar", 1)
	SendNoEcho ("board epics")
	SendNoEcho ("note list")
	
end -- ResetEpicTable

function EpicUpdateEnd()
	world.EnableGroup ("EpicCalendar", 0)
	world.EnableGroup ("EpicUpdateEnd", 0)

	if EpicMisc["NotificationBot"]["Enabled"] == true and EpicMisc["NotificationBot"]["Warning"]["Enabled"] == true then
		GetNextEpicSilent()
	end

	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "YES" then
			table.remove (EpicTable, i)
		end
	end
	
	if rcheck == "YES" then
		rcheck = "NO"
		ColourNote(msg_colour, "", "Epic list has been updated.")
	end
	
	world.EnableGroup ("GetBoardEndTrig", 1)
	
	SendNoEcho ("board " .. cboard)
	
	SaveState()
end -- EpicUpdateEnd

function EpicNote(name, line, wc)
	cname = string.lower(wc[2])
	
	if (CheckMob(cname) == "no") then		
		ResetEpicTable()
	end
end -- EpicNote

function EpicBoard(name, line, wc)
	notenum = tonumber(wc[1])
	notedate = wc[2]
	cname = string.lower(wc[3])
	
	if (CheckMob(cname) == "no") then
		subjectline = string.lower(wc[4])
		AddEpic(notenum, notedate, cname, subjectline)
	end
end -- EpicBoard

function AddEpic(notenum, notedate, cname, subjectline)
	epiccheck = "NO"	
	aftercheck = "NO"
	afterepic = ""
	beforecheck = "NO"
	beforeepic = ""
	beforeepicorig = ""
	afterepicorig = ""
	todaycheck = "NO"
	
	rsub = subjectline
	rwords = utils.split (rsub, " ")
	
	if rwords[1] == "re:" then return end
	
	invalid_characters = ":~!@#$%^&*()_+=-{}[];'|?.,<>"
	invalid_characters_pattern = "["..string.gsub(invalid_characters, ".", "%%%1").."]"

	subjectline2 = subjectline
	subjectline = string.gsub(subjectline, invalid_characters_pattern, "")
	
	subjectline = subjectline:gsub("  ", " ")

	wordtable = utils.split (subjectline, " ")
	checkdate = nil

	timecheck = "NO"
	
	for time in subjectline:gmatch("(%d+[%s+]*[ap]m)") do
		time = time:gsub(" ", "")
		
		timecheck = "YES"
		
	end

	if timecheck == "NO" then return end
	
	-- for i,v in ipairs(EpicTable) do
		-- if (tonumber(EpicTable[i]["Note Number"])) == notenum then
			-- return
		-- end
	-- end
	
	for wordindex,b in ipairs(wordtable) do
	
		for i,v in ipairs(wordtable) do
			if wordtable[i] == "after" then
				j = i + 1

				aftercheck = "YES"
				afterepic = wordtable[j]
				afterepicorig = wordtable[j]
				
				if afterepic == "if2" then
					afterepic = "icefall2"
				elseif afterepic == "if1" then
					afterepic = "icefall1"
				elseif afterepic == "if" then
					afterepic = "icefall1"
				end		
			elseif wordtable[i] == "before" then
				j = i + 1
				
				beforecheck = "YES"
				beforeepic = wordtable[j]
				beforeepicorig = wordtable[j]
				
				if beforeepic == "if2" then
					beforeepic = "icefall2"
				elseif beforeepic == "if1" then
					beforeepic = "icefall1"
				elseif beforeepic == "if" then
					beforeepic = "icefall1"
				end		
			elseif wordtable[i] == "today" then
				todaycheck = "YES"
			end
		end
		
		epname = ""
		
		for i,v in ipairs(EpicNames) do
			if (CheckEpic(EpicNames[i], wordtable[wordindex])) ~= nil and wordtable[wordindex] ~= afterepicorig and wordtable[wordindex] ~= beforeepicorig then 
				epiccheck = "YES"
				
				TableIndex = TableIndex + 1	
				
				if EpicTable[TableIndex] == nil then			
					EpicTable[TableIndex] = {}
					EpicTable[TableIndex]["Index"] = TableIndex
				end
				
				if EpicTable[TableIndex]["Epic Name"] == nil then
					if EpicNames[i] == "if1" then
						EpicTable[TableIndex]["Epic Name"] = "icefall1"
						epname = "icefall1"
					elseif EpicNames[i] == "if2" then
						EpicTable[TableIndex]["Epic Name"] = "icefall2"
						epname = "icefall2"
					else
						EpicTable[TableIndex]["Epic Name"] = EpicNames[i]
						epname = EpicNames[i]
					end
				end
				
 				if i == 9 then 
					if wordtable[wordindex] == "icefall1" or wordtable[wordindex] == "icefall2" then
						TableIndex = TableIndex - 1
						EpicTable[TableIndex]["Epic Name"] = wordtable[wordindex]
						epname = wordtable[wordindex]
					end
				end
			end
		end

		for j,k in ipairs(EpicTable) do
			if EpicTable[j]["Note Number"] == notenum then
				if EpicTable[j]["Epic Name"] == epname then
					epiccheck = "NO"
					table.remove (EpicTable, TableIndex)
					TableIndex = TableIndex - 1
				end
			end
		end				

		if epiccheck == "YES" then
			EpicTable[TableIndex]["Epic Leader"] = cname
			EpicTable[TableIndex]["Note Number"] = notenum
			EpicTable[TableIndex]["Note Date"] = notedate
		
			if todaycheck == "YES" then
				tindex = SystemTimeTable["wday"]
				EpicTable[TableIndex]["Day of Week"] = DaysofWeekShort[tindex]
			else
				DayCheck = "NO"

				for i,v in ipairs(DaysofWeekShort) do
					for q,r in ipairs(wordtable) do
					
						search = wordtable[q]
						SearchItem = DaysofWeekShort[i]
						
						len = string.len(SearchItem)

						for j,k in pairs(string.split(search," ")) do
							if string.find(string.sub(k,1,len),SearchItem) == nil then
							else
								DayCheck = "YES"
								EpicTable[TableIndex]["Day of Week"] = DaysofWeekShort[i]
							end
						end
					end
				end

				if DayCheck == "NO" then
					EpicTable[TableIndex]["Day of Week"] = "UNKNOWN"
				end
			end
			
			for date in subjectline2:gmatch("%a%a%a%d%d") do
				SeperateDate(date)
				checkdate = date
			end

			if checkdate == nil then 
				if DayCheck == "YES" then
					NoDateFound()
				end
			end

			timecheck = "NO"
			
			for time in subjectline:gmatch("(%d+[%s+]*[ap]m)") do
				time = time:gsub(" ", "")
				
				timecheck = "YES"
				
				for tday in time:gmatch("[ap]m") do
					EpicTable[TableIndex]["AMPM"] = tday
				end
				
				SeperateTime(time)
				PopulateTimeTable(TableIndex)
			end

			if aftercheck == "YES" then
				for i,v in ipairs(EpicTable) do
					if EpicTable[TableIndex]["Day of Week"] == EpicTable[i]["Day of Week"] then
						if EpicTable[i]["Epic Name"] == afterepic then
							if timecheck ~= "YES" then
								EpicTable[TableIndex]["Hour"] = EpicTable[i]["Hour"]
								EpicTable[TableIndex]["Time Table"] = EpicTable[i]["Time Table"]
								EpicTable[TableIndex]["Minute"] = EpicTable[i]["Minute"]
								EpicTable[TableIndex]["AMPM"] = EpicTable[i]["AMPM"]				
							end
						end
					end
				end			
			elseif beforecheck == "YES" then
				for i,v in ipairs(EpicTable) do
					if EpicTable[TableIndex]["Day of Week"] == EpicTable[i]["Day of Week"] then

						if EpicTable[i]["Epic Name"] == beforeepic then
							if timecheck ~= "YES" then
								EpicTable[TableIndex]["Hour"] = EpicTable[i]["Hour"]
								EpicTable[TableIndex]["Time Table"] = EpicTable[i]["Time Table"]
								EpicTable[TableIndex]["Minute"] = EpicTable[i]["Minute"]
								EpicTable[TableIndex]["AMPM"] = EpicTable[i]["AMPM"]
							end
						end
					end
				end
			end
		end
		
		if (GetTriggerOption ("EpicUpdateEnd", "enabled")) == 0 then		
			world.EnableGroup ("EpicUpdateEnd", 1)
			
		end
	end
end -- AddEpic

function NoDateFound()
	EpicTable[TableIndex]["Time Table"] = {}
    EpicTable[TableIndex]["Time Table"]["month"] = SystemTimeTable["month"]

	dayindexstart = SystemTimeTable["wday"] -- start with the system's today, i.e. saturday would be 7
	day = EpicTable[TableIndex]["Day of Week"] -- we need the day of week from epic post
	ydaydif = 0
	
	for i = 1, 8, 1 do
		if DaysofWeekShort[dayindexstart] ~= day then
			ydaydif = ydaydif + 1
			dayindexstart = dayindexstart + 1
		else
			break
		end
	
		if dayindexstart > 7 then
			dayindexstart = 1
		end
	end
	
	currentday = SystemTimeTable["day"] + ydaydif
	
	mdindex = EpicTable[TableIndex]["Time Table"]["month"]
	
	maxdays = MonthMaxDays[mdindex]
	
	if currentday > maxdays then
		EpicTable[TableIndex]["Time Table"]["day"] = currentday - maxdays
		EpicTable[TableIndex]["Time Table"]["month"] = EpicTable[TableIndex]["Time Table"]["month"] + 1
		if EpicTable[TableIndex]["Time Table"]["month"] > 12 then
			EpicTable[TableIndex]["Time Table"]["month"] = 1
			EpicTable[TableIndex]["Time Table"]["year"] = EpicTable[TableIndex]["Time Table"]["year"] + 1
		end
	else
		EpicTable[TableIndex]["Time Table"]["day"] = currentday
	end
end -- NoDateFound

function PopulateTimeTable(TableIndex)	
	EpicTable[TableIndex]["Time Table"]["sec"] = 0
	EpicTable[TableIndex]["Time Table"]["min"] = tonumber(EpicTable[TableIndex]["Minute"])

	EpicTable[TableIndex]["Time Table"]["hour"] = 0

	if EpicTable[TableIndex]["AMPM"] == "pm" then 
		EpicTable[TableIndex]["Time Table"]["hour"] = EpicTable[TableIndex]["Time Table"]["hour"] + 12
	end
	
	EpicTable[TableIndex]["Time Table"]["hour"] = EpicTable[TableIndex]["Time Table"]["hour"] + tonumber(EpicTable[TableIndex]["Hour"])

	EpicTable[TableIndex]["Time Table"]["year"] = SystemTimeTable["year"]

	for i,v in ipairs(DaysofWeekShort) do
		search = EpicTable[TableIndex]["Day of Week"]
		SearchItem = DaysofWeekShort[i]
		
		len = string.len(SearchItem)

		for j,k in pairs(string.split(search," ")) do
			if string.find(string.sub(k,1,len),SearchItem) == nil then
			else
				EpicTable[TableIndex]["Time Table"]["wday"] = i
			end
		end
	end

	MonthIndex = EpicTable[TableIndex]["Time Table"]["month"]
	yday = MonthsYDay[MonthIndex] + EpicTable[TableIndex]["Time Table"]["day"]
	
	if (SystemTimeTable["year"]%4) == 0 then yday = yday + 1 end
	
	EpicTable[TableIndex]["Time Table"]["yday"] = yday
	
	EpicTable[TableIndex]["Time Table"]["isdst"] = false
end -- PopulateTimeTable

function EpicList()
	listtype = "list"
	GetSystemTime()
end -- EpicList

function CheckType(ltype)
	SearchNames = {
		["genie"] = "Genie's Last Wish",
		["inferno"] = "Journey to the Inferno",
		["oc"] = "Oradrins Chosen",
		["winds"] = "Winds of Fate",
		["terra"] = "Cracks of Terra",
		["titan"] = "Titans Keep",
		["oldvanir"] = "oldvanir",
		["testmaze10"] = "testmaze10",
		["transcendence"] = "transcendence", 
	}

	if ltype == "if1" or ltype == "icefall 1" then
		ltype = "icefall1" 
		return ltype
	elseif ltype == "if2" or ltype == "icefall 2" then
		ltype = "icefall2"
		return ltype
	elseif ltype == "if" then
		ltype = "icefall"
		return ltype
	end

	for i,v in pairs(SearchNames) do
		search = string.lower(v)
		SearchItem = string.lower(trim(ltype))

		len = string.len(SearchItem)

		invalid_characters = "~!@#$%^&*()_+=-{}[];'|?.,<>"
		invalid_characters_pattern = "["..string.gsub(invalid_characters, ".", "%%%1").."]"

		SearchItem = string.gsub(SearchItem, invalid_characters_pattern, "")
		
		SearchItem = SearchItem:gsub("  ", " ")

		if string.find(search,SearchItem) == nil then
		else
			ltype = i
		end
	end
	
	return ltype
end

function SearchEpic(epicname)
	if EpicTable == nil then
		ColourNote(msg_colour, "", "You have not updated the epic run list. Please see ", qty_colour, "", "ecal help", msg_colour, "", " for more information.")
		return
	end
	
	if epicname == nil then
		ColourNote(msg_colour, "", "Please enter an epic name to search for.")
		return
	end
	
	local ltype = string.lower(epicname)
	listtype = CheckType(ltype)
	
	if listtype == nil then listtype = ltype end
	
	GetSystemTime()
end -- SearchEpic

function ListEpic()		
	local hour = ""

	if listtype == "nextleader" then
		ColourNote(msg_colour, "", "Please specify a leader to look up")
		return
	end

	if listtype == "list" then		
		title = "Epic Run List"
	else
		title = "Epic Run List - Searching: " .. listtype
	end
	
	local title2 = "+-----------+------------+-----------+----------+---------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	ColourNote(msg_colour, "", title2)
	ColourNote(msg_colour, "", "| Epic      | Leader     | Day       | Time     | Time Until Epic                 |")
	ColourNote(msg_colour, "", title2)
	
	errorcheck = "no"
	
	for i,v in ipairs (EpicTable) do
		if EpicTable[i]["Time Table"]["year"] == nil then
			errorcheck = "yes"
		end
	end
	
	if errorcheck ~= "yes" then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)
	end
	
	if listtype == "list" then
		for i,v in ipairs(EpicTable) do
			if EpicTable[i]["Epic Name"] == "icefall1" then
				ename = "Icefall 1"
			elseif EpicTable[i]["Epic Name"] == "icefall2" then
				ename = "Icefall 2"
			elseif EpicTable[i]["Epic Name"] == "oc" then
				ename = "OC"
			elseif EpicTable[i]["Epic Name"] == "transcendence" then
				ename = "Transcend"
			else 
				if EpicTable[i]["Epic Name"]~= nil then 
					ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
				end
			end
			
			if EpicTable[i]["Epic Leader"] ~= nil then
				eleader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)
			end

			dindex = EpicTable[i]["Time Table"]["wday"]
			
			if DaysofWeek[dindex] ~= nil then 
				eday = string.gsub (DaysofWeek[dindex], "^.", string.upper)
			end
			
			if EpicTable[i]["Time Table"]["hour"] ~= nil then
				ReturnType = "normal"
				timedef = EpicTimeDifference(i, ReturnType)

				if EpicTable[i]["Time Table"]["min"] ~= 0 then
					hour = EpicTable[i]["Hour"] .. ":" .. EpicTable[i]["Time Table"]["min"] .. " " .. string.upper(EpicTable[i]["AMPM"])
				else
					hour = EpicTable[i]["Hour"] .. ":00 " .. string.upper(EpicTable[i]["AMPM"])
				end
			end

			if timedef ~= nil then
				timedef = trim(timedef)
			end
			
			DisplayRow(ename, eleader, eday, hour, timedef)		
		end
	else
		len = string.len(listtype)

		for i,v in ipairs(EpicTable) do
			epicname = EpicTable[i]["Epic Name"]
			
			if string.find(string.sub(epicname,1,len),listtype) ~= nil then			
				if EpicTable[i]["Epic Name"] == "icefall1" then
					ename = "Icefall 1"
				elseif EpicTable[i]["Epic Name"] == "icefall2" then
					ename = "Icefall 2"
				elseif EpicTable[i]["Epic Name"] == "oc" then
					ename = "OC"
				elseif EpicTable[i]["Epic Name"] == "transcendence" then
					ename = "Transcend"
				else 
					ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
				end

				eleader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)

				dindex = EpicTable[i]["Time Table"]["wday"]
			
				eday = string.gsub (DaysofWeek[dindex], "^.", string.upper)
				
				if EpicTable[i]["Time Table"]["hour"] ~= nil then
					ReturnType = "normal"
					timedef = EpicTimeDifference(i, ReturnType)

					if EpicTable[i]["Time Table"]["min"] ~= 0 then
						hour = EpicTable[i]["Hour"] .. ":" .. EpicTable[i]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[i]["AMPM"])
					else
						hour = EpicTable[i]["Hour"] .. ":00 " .. string.upper(EpicTable[i]["AMPM"])
					end
				end

				if timedef ~= nil then
					timedef = trim(timedef)
				end
				
				DisplayRow(ename, eleader, eday, hour, timedef)
			end
		end
	end

	ColourNote(msg_colour, "", title2)
end -- ListEpic

function DisplayRow(ename, eleader, eday, hour, timedef)
	if timedef == nil then
		timedef = "This Epic is over"
		return
	end

	if ename == nil then namespace = 9 else namespace = MakeSpace(ename, 9) end

	if eleader == nil then leaderspace = 10 else leaderspace = MakeSpace(eleader, 10) end

	if eday == nil then dayspace = 9 else dayspace = MakeSpace(eday, 9) end
	
	if hour == nil then timespace = 8 else timespace = MakeSpace(hour, 8) end
	
	if timedef == nil then remainspace = 31 else remainspace = MakeSpace(timedef,31) end
	
	ColourNote(msg_colour, "", "| ", epic_colour, "", ename .. namespace, msg_colour, "", " | ", leader_colour, "", eleader .. leaderspace, msg_colour, "", " | ", day_colour, "", eday .. dayspace, msg_colour, "", " | ", time_colour, "", timespace .. hour, msg_colour, "", " | ", remain_colour, "",remainspace .. timedef, msg_colour, "", " |")
end -- DisplayRow

function StartPost()
	listtype = "post"	
	GetSystemTime()
end -- StartPot()

function StartNotePost()
	SendNoEcho ("board personal")
	SendNoEcho ("note write")
	SendNoEcho (noteuser)
	SendNoEcho ("Epic Run Schedule")
	PostEpic()
end -- StartNotePost

function PostEpic()
	local hour = ""

	local title = "Epic Run List"
	local title2 = "+---------+----------+---------+--------+-------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	SendNoEcho (spacing .. "@R" .. title .. "@w")
	SendNoEcho ("@w")
	SendNoEcho ("@D" .. title2)
	SendNoEcho ("@D| Epic    | Leader   | Day     | Time   | Time Until Epic               |@w")
	SendNoEcho ("@D" .. title2)
	
	table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)

	for i,v in ipairs(EpicTable) do
		if EpicTable[i]["Epic Name"] == "icefall1" then
			ename = "Icefall 1"
		elseif EpicTable[i]["Epic Name"] == "icefall2" then
			ename = "Icefall 2"
		elseif EpicTable[i]["Epic Name"] == "oc" then
			ename = "OC"
		elseif EpicTable[i]["Epic Name"] == "transcendence" then
			ename = "Transcend"
		else 
			ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
		end

		eleader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)
		
		dindex = EpicTable[i]["Time Table"]["wday"]

		eday = string.gsub (DaysofWeek[dindex], "^.", string.upper)
		
		if EpicTable[i]["Time Table"]["hour"] ~= nil then
			ReturnType = "normal"
			timedef = EpicTimeDifference(i, ReturnType)

			if EpicTable[i]["Time Table"]["min"] ~= 0 then
				hour = EpicTable[i]["Hour"] .. ":" .. EpicTable[i]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[i]["AMPM"])
			else
				hour = EpicTable[i]["Hour"] .. ":00 " .. string.upper(EpicTable[i]["AMPM"])
			end
		end
		
		if timedef ~= nil then
			PostRow(ename, eleader, eday, hour, timedef)
		end
	end
		
	SendNoEcho ("@D" .. title2)
	SendNoEcho ("@w")
	
	since = os.time (SystemTimeTable)
	since = os.date ("%a, %d %b %Y - %I:%M:%S %p", since)
	timestamp = "List generated: " .. since .. " (server time)"
	
	SendNoEcho (timestamp)
	SendNoEcho ("end")
	SendNoEcho ("p")
end -- PostEpic

function PostRow(ename, eleader, eday, hour, timedef)
	if ename == nil then namespace = 9 else namespace = MakeSpace(ename, 9) end

	if eleader == nil then leaderspace = 10 else leaderspace = MakeSpace(eleader, 10) end

	if eday == nil then dayspace = 9 else dayspace = MakeSpace(eday, 9) end
	
	if hour == nil then timespace = 8 else timespace = MakeSpace(hour, 8) end
	
	if timedef == nil then remainspace = 32 else remainspace = MakeSpace(timedef,32) end
	
	SendNoEcho ("@D|@R" .. ename .. namespace .. "@D|@Y" .. eleader .. leaderspace .. "@D|@w" .. eday .. dayspace .. "@D|@w" .. timespace .. hour .. "@D|@G" .. remainspace .. trim(timedef) .. "@D|@w")
end -- PostRow

-----------------------------------------------
------------ NOTE UPDATE FUNCTIONS ------------
-----------------------------------------------
function NoteUpdate(nnum)
	world.EnableGroup ("NoteUpdate", 1)
	world.EnableGroup ("NoteUpdateLine1", 1)
	
	ColourNote(msg_colour, "", "Checking subject line for note #", qty_colour, "", nnum)
	

	SendNoEcho ("board epics")	
	SendNoEcho ("note read " .. nnum)
end -- NoteUpdate

function NoteUpdateEnd()
	tablecount = table.maxn (EpicTable)

	TableIndex = tablecount
	
	world.EnableGroup ("NoteUpdate", 0)
	world.EnableGroup ("NoteUpdateEnd", 0)
	world.EnableGroup ("NoteUpdateNoteContent", 0)
	
	if (CheckMob(nuleader) == "no") then
		AddEpic(nunotenum, nunotedate, nuleader, nusubjectline)
	end
end -- NoteUpdateEnd

function NoteUpdateSubject(name, line, wc)
	world.EnableGroup ("NoteUpdateLine1", 0)
	world.EnableGroup ("NoteUpdateLine2", 1)

	nuleader = string.lower(wc[1])
	nusubjectline = string.lower(wc[2])
end -- NoteUpdateSubject

function NoteUpdateEnableEnd()
	world.EnableGroup ("NoteUpdateLine2", 0)
	world.EnableGroup ("NoteUpdateEnd", 1)
	world.EnableGroup ("NoteUpdateNoteContent", 1)
end

function NoteUpdateNoteNum(name, line, wc)
	nuboard = string.lower(wc[1])
	
	if nuboard == "epics" then
		nunotenum = tonumber(wc[2])
	else
		nunotenum = "error"
	end
end -- NoteUpdateNoteNum

function NoteUpdateNoteDate(name, line, wc)
	month = wc[2]
	day = wc[3]
	hour = wc[4]
	min = wc[5]
	
	if string.len(day) == 1 then day = "0" .. day end
	
	nunotedate = day .. " " .. month .. " " .. hour .. ":" .. min
end -- NoteUpdateNoteDate

----------------------------------------------
--------------- NEXT FUNCTIONS ---------------
----------------------------------------------
function GetNextEpicLeader(leader, channel)
	if leader == nil then
		ColourNote(msg_colour, "", "Please specify a leader to look up")
		return
	else
		wnext = string.lower(leader)
	end
	
	LeaderSearch = "YES"

	if channel ~= nil then
		reportchannel = channel
	end
	
	listtype = "next"
	GetSystemTime()
end -- GetNextEpicLeader

function GetNextEpicDay(wday, channel)
	if wday ~= nil then
		wday = string.lower(wday)
	end

	DaySearch = "YES"
	wnext = nil
		
	if string.len(wday) < 3 then
		if channel ~= nil then
			SendNoEcho (channel .. " @R[EpicCAL] @DYou must input at least 3 characters of the day.@w")
		else
			ColourNote(msg_colour, "", "You must input at least 3 characters of the day.")
		end
		
		return
	elseif string.len(wday) == 3 then
		for i,v in ipairs(DaysofWeekShort) do
		
			len = string.len(DaysofWeekShort[i])
			day = DaysofWeekShort[i]
			search = wday

			if string.find(string.sub(search,1,len),day) ~= nil then
				wnext = day
			end
		end
	else
		for i,v in ipairs(DaysofWeek) do
		
			len = string.len(wday)
			search = DaysofWeek[i]

			if string.find(string.sub(search,1,len),wday) ~= nil then
				wnext = DaysofWeekShort[i]
			end
		end
	end

	if wnext ~= nil then
		if channel ~= nil then
			reportchannel = channel
		end
		
		listtype = "next"
		GetSystemTime()
	else
		if channel ~= nil then
			SendNoEcho (channel .. " @R[EpicCAL] @C" .. wday .. " @Dis not a valid day.@w")
		else
			ColourNote(qty_colour, "", wday, msg_colour, "", " is not a valid day.")
		end
	end
end -- GetNextEpicDay

function GetNextEpic(ename, channel)	
	if ename ==  nil then
		wnext = nil
	else
		wnext = string.lower(ename)
	end
	
	if channel ~= nil then
		reportchannel = channel
	end

	listtype = "next"
	GetSystemTime()
end -- GetNextEpic

function GetLowestDay(lowestindex)
	ReturnType = "normal"
	timeremaining = EpicTimeDifference(lowestindex, ReturnType)

	if SystemTimeTable["wday"] == EpicTable[lowestindex]["Time Table"]["wday"] then
		day = "today"
	else
		dayindex = EpicTable[lowestindex]["Time Table"]["wday"]
		day = DaysofWeek[dayindex]
	end
	
	day = string.gsub (day, "^.", string.upper)
	return day
end -- GetLowestDay

function GetNextEpicSilent()
	silentcheck = "YES"
	
	listtype = "next"
	GetSystemTime()
end -- GetNextEpicSilent

function NextEpic()
	lowestseconds = 604800 -- amount of seconds in a week 
	lowestindex = 0 -- index of epic with lowest amount of seconds

	table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)

	if DaySearch == "YES" then
		DaySearch = "NO"
		
		for i,v in ipairs(EpicTable) do
			day = EpicTable[i]["Day of Week"]

			if wnext == day then
				CheckLowest(i)
			end
		end

		if lowestindex > 0 then
			day = GetLowestDay(lowestindex)
			nexttype = "day"
			DisplayNext(nexttype, day, lowestindex)
		else
			nexttype = "day"
			day = wnext
			DisplayNextFail(nexttype, day, wnext)
		end

	elseif LeaderSearch == "YES" then
		LeaderSearch = "NO"

		for i,v in ipairs(EpicTable) do
			local search = EpicTable[i]["Epic Leader"]
		
			len = string.len(wnext)

			for j,k in pairs(string.split(search," ")) do
				if string.find(string.sub(k,1,len),wnext) ~= nil then
					CheckLowest(i)
				end
			end
		end
		
		if lowestindex > 0 then
			day = GetLowestDay(lowestindex)			
			nexttype = "leader"
			DisplayNext(nexttype, day, lowestindex)
		else
			nexttype = "leader"
			DisplayNextFail(nexttype, day, wnext)
		end
	else	
		if wnext == "epic" or wnext == nil then
			for i, v in ipairs(EpicTable) do
				CheckLowest(i)
			end

			if lowestindex > 0 then
				if silentcheck == "YES" then
					silentcheck = "NO"
					ReturnType = "table"
					timeremaining = EpicTimeDifference(lowestindex, ReturnType)

					if timeremaining["hour"] <= 2 then
						EnableNextEpicNotification(lowestindex, timeremaining)
					elseif timeremaining["hour"] == 3 then
						if timeremaining["min"] < 0 then
							if timeremaining["sec"] < 0 then
								EnableNextEpicNotification(lowestindex, timeremaining)
							end
						end
					end
				else
					day = GetLowestDay(lowestindex)
					
					nexttype = "epic"
					DisplayNext(nexttype, day, lowestindex)
				end
			else
				nexttype = "epic"
				DisplayNextFail(nexttype, day, wnext)
			end
		else
			wnext = string.lower(wnext)
			wnext = CheckType(wnext)

			len = string.len(wnext)

			for i,v in ipairs(EpicTable) do
				epicname = EpicTable[i]["Epic Name"]

				if string.find(string.sub(epicname,1,len),wnext) ~= nil then		
					CheckLowest(i)
				end
			end
	
			if lowestindex > 0 then
				day = GetLowestDay(lowestindex)				
				nexttype = "search"
				DisplayNext(nexttype, day, lowestindex)
			else
				nexttype = "search"
				DisplayNextFail(nexttype, day, wnext)
			end
		end
	end
end -- NextEpic

function DisplayNext(nexttype, day, lowestindex)
	if EpicTable[lowestindex]["Epic Name"] == "icefall1" then
		ename = "Icefall 1"
	elseif EpicTable[lowestindex]["Epic Name"] == "icefall2" then
		ename = "Icefall 2"
	elseif EpicTable[lowestindex]["Epic Name"] == "oc" then
		ename = "OC"
	else
		if EpicTable[lowestindex]["Epic Name"] ~= nil then
			ename = string.gsub (EpicTable[lowestindex]["Epic Name"], "^.", string.upper)
		end
	end
	
	eleader = EpicTable[lowestindex]["Epic Leader"]
	eleader = string.gsub (eleader, "^.", string.upper)
	
	if nexttype == "day" then
		if reportchannel == nil then
			note = {"red", "", "[", "yellow", "", day, "red", "", "'s first epic: ", "cyan", "", ename}
		else
			message = "@R[@Y" .. day .. "@R's first epic: @C" .. ename
		end
	elseif nexttype == "leader" then
		if reportchannel == nil then
			note = {"red", "", "[", "yellow", "", eleader, "red", "", " next epic ", "cyan", "", ename, msg_colour, "", " / ", "red", "", day}
		else
			message = "@R[@Y" .. eleader .. " @Rnext epic: @C" .. ename .. " @D/ @R" .. day
		end
	elseif nexttype == "search" then
		if reportchannel == nil then
			note = {"red", "", "[Next ", "cyan", "", ename, "red", "", ":", msg_colour, "", " / ", "red", "", day}
		else
			message = "@R[Next @C" .. ename .. "@R: " .. day
		end
	elseif nexttype == "epic" then
		if reportchannel == nil then
			note = {"red", "", "[Next epic: ", "cyan", "", ename, msg_colour, "", " - ", "red", "", day}
		else
			message = "@R[Next epic: @C" .. ename .. " @D- @R" .. day
		end
	end

	if EpicTable[lowestindex]["Time Table"]["min"] ~= 0 then
		hour = EpicTable[lowestindex]["Hour"] .. ":" .. EpicTable[lowestindex]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[lowestindex]["AMPM"])
	else
		hour = EpicTable[lowestindex]["Hour"] .. ":00 " .. string.upper(EpicTable[lowestindex]["AMPM"])
	end

	if reportchannel == nil then
		table.insert(note, msg_colour)
		table.insert(note, "")
		table.insert(note, " / ")
		table.insert(note, "red")
		table.insert(note, "")
		table.insert(note, hour)
		table.insert(note, msg_colour)
		table.insert(note, "")
		table.insert(note, " / ")
		table.insert(note, "lime")
		table.insert(note, "")
		
		if timeremaining ~= nil then
			table.insert(note, trim(timeremaining))
		end
		
		table.insert(note, "red")
		table.insert(note, "")
		table.insert(note, "]")

		ColourNote(unpack(note))
	else 
		if timeremaining ~= nil then
			timeremaining = trim(timeremaining)
		end

		message = message .. " @D/ @R" .. hour .. " @D/ @G" .. timeremaining  .. "@R]@w"
		Send(reportchannel .. " " .. message)
		reportchannel = nil	
	end
end -- DisplayNext

function DisplayNextFail(nexttype, day, wnext)
	if EpicTable[1] == nil then
		ColourNote(msg_colour, "", "ERROR no data found in epic table")
	else
		if wnext == "epic" or wnext == nil then
			if nexttype == "day" then
				endnote = " for that day."
			elseif nexttype == "leader" then
				endnote = " for that leader."
			elseif nexttype == "search" or nexttype == "epic" then
				endnote = "."
			end
			
			ColourNote(msg_colour, "", "There are no epic runs scheduled .. endnote")
		else
			if nexttype == "day" or nexttype == "leader" then
				if nexttype == "day" then
					for i,v in ipairs(DaysofWeekShort) do
						if day == DaysofWeekShort[i] then
							sendwhat = DaysofWeek[i]
						end
					end
				elseif nexttype == "leader" then
					sendwhat = wnext
				end

				if reportchannel == nil then
					ColourNote(msg_colour, "", "There are no epic runs scheduled for ", help_command_colour, "", sendwhat, msg_colour, "", ".")
				else
					SendNoEcho (reportchannel .. " @R[EpicCAL] @DThere are no epic runs scheduled for @C" .. sendwhat .. "@D.@w")
					reportchannel = nil
				end
			elseif nexttype == "epic" or nexttype == "search" then
				if reportchannel == nil then
					ColourNote(msg_colour, "", "There are no ", help_command_colour, "", wnext, msg_colour, "", " epic runs scheduled.")
				else
					SendNoEcho (reportchannel .. " @R[EpicCAL] @DThere are no @C" .. wnext .. " @Depic runs scheduled.@w")
					reportchannel = nil
				end	
			end
		end
	end
end -- DisplayNextFail

---------------------------------------------
--------------- BOT FUNCTIONS ---------------
---------------------------------------------
function BotHelp(channel, user, cmd)
	if cmd == "nextepic" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!nextepic <epic> @D- displays when the next specified epic is scheduled. Using @R!nextepic @Don its own will display the next scheduled epic.@w")
	elseif cmd == "nextday" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!nextday <day> @D- displays the first epic of the day on that particular day@w")
	elseif cmd == "nextleader" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!nextleader <leader> @D- displays the first epic scheduled for that particular leader@w")
	elseif cmd == "listepic" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!listepic @D- displays the entire epic schedule on one line sorted by day. @C!listepic leader @Dand @C!listepic epic @Dwill display the schedule but grouped together. @C!listepic <epic name> @Dwill display only that particular epic. And finally @C!listepic note @Dwill send the schedule to the user via a note.@w")
	elseif cmd == "listday" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!listday @D- displays the entire epic schedule for today. @C!listday <day> @Dwill display the full schedule for that paritcular day.@w")
	elseif cmd == "noteremove" then
		SendNoEcho (channel .. " @R[EpicCAL] @C!noteremove <notenum> @D- will request the bot to remove the schedule note@w")
	elseif cmd == "todo" then
		SendNoEcho (channel .. " @R[EpicCAL] @Dsend for beta testing to help with @Cerror trapping@w")
	else
		user = string.gsub (user, "^.", string.upper)
		SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D, that is not a valid option.@w")
	end
end -- BotHelp
	
function AutoAddRemoveChannel(cmd, channel)	
	if cmd == "add" then
		if channel ~= nil then
			if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
				ColourNote(qty_colour, "", channel, msg_colour, "", " channel has been added to the auto notification list and has been set to off by by default")
				EpicMisc["NotificationBot"]["Auto"][channel] = false
			else
				ColourNote(qty_colour, "", channel, msg_colour, "", " has already been added to the auto notification list")
			end
		else
			ColourNote(msg_colour, "", "Please specify which channel you would like to add.")
		end
	elseif cmd == "remove" then
		if channel ~= nil then
			if EpicMisc["NotificationBot"]["Auto"][channel] == nil then
				ColourNote(qty_colour, "", channel, msg_colour, "", " was not on the auto notification list")
			else
				ColourNote(qty_colour, "", channel, msg_colour, "", " channel has been removed from the auto notification list")
				EpicMisc["NotificationBot"]["Auto"][channel] = nil
			end
		else
			ColourNote(msg_colour, "", "Please specify which channel you would like to remove.")
		end
	end
	
	SaveState()
end -- AutoAddRemoveChannel

function ListPermissions()
	title = "Bot Permissions List"
	
	local title2 = "+--------------+--------------------------------+--------------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	ColourNote(msg_colour, "", title2)
	ColourNote(msg_colour, "", "| Name         | On List Since                  | Time on List                               |")
	ColourNote(msg_colour, "", title2)
	
	IndexedEpicPermissionTable = {}

	for k, v in pairs(EpicPermissionTable) do
		table.insert(IndexedEpicPermissionTable, {["Name"]=k, ["Since"]=v["Since"]})
	end

	table.sort(IndexedEpicPermissionTable, function (a, b) local atime = os.time(a["Since"]); local btime = os.time(b["Since"]); if atime == btime then return a["Name"] > b["Name"] else return atime > btime end end)

	for i,v in ipairs(IndexedEpicPermissionTable) do

		user = string.gsub (IndexedEpicPermissionTable[i]["Name"], "^.", string.upper)
		since = os.date ("%a, %d %b %Y - %I:%M:%S %p", os.time(IndexedEpicPermissionTable[i]["Since"]))
		
		local timenow = os.time()
		local timenow2 = os.time(IndexedEpicPermissionTable[i]["Since"])
		
		local timediff2 = {}

		timeDiff(timenow,timenow2,timediff2)

		local timeonlist = remainingtime_note(timediff2)
		
		if user == nil then namespace = 12 else namespace = MakeSpace(user, 12) end
		
		if since == nil then sincespace = 30 else sincespace = MakeSpace(since, 30) end
		
		if timeonlist == nil then onlistspace = 42 else onlistspace = MakeSpace(timeonlist, 42) end

		ColourNote(msg_colour, "", "| ", epic_colour, "", user .. namespace, msg_colour, "", " | ", leader_colour, "", since .. sincespace, msg_colour, "", " | ", remain_colour, "", timeonlist .. onlistspace, msg_colour, "", " |")
	end

	ColourNote(msg_colour, "", title2)
end -- ListPermissions

function ListChannels(cmd)
	if cmd == "auto" then
		title = "Auto Notification Channels"
		display = "Auto"
	elseif cmd == "commands" then
		title = "Command System Channels"
		display = "Commands"
	end
	
	local title2 = "+---------+----------+"
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	ColourNote(msg_colour, "", title2)
	ColourNote(msg_colour, "", "| Channel |  Status  |")
	ColourNote(msg_colour, "", title2)
	
	for i, v in pairs(EpicMisc["NotificationBot"][display]) do
		if v == false then
			display_colour = "red" 
			displayname = "OFF"
		elseif v == true then
			display_colour = "green"
			displayname = "ON"
		end
	
		if i == nil then channelspace = 7 else channelspace = MakeSpace(i, 7) end
		
		if display == nil then displayspace = 3 else displayspace = MakeSpace(displayname, 3) end
		
		ColourNote(msg_colour, "", "| ", epic_colour, "", i .. channelspace, msg_colour, "", " |   ", display_colour, "", displayname .. displayspace, msg_colour, "", "    | ")
	end

	ColourNote(msg_colour, "", title2)
end -- ListChannels

function UserPermission(cmd, user)		
	if cmd == "add" then
		addcheck = "NO"
		
		for i,v in pairs(EpicPermissionTable) do			
			if i == user then
				addcheck = "YES"
			end
		end
		
		if addcheck == "NO" then
			EpicPermissionTable[user] = {}
			EpicPermissionTable[user]["Since"] = os.date("*t")
			user = string.gsub (user, "^.", string.upper)
			ColourNote(qty_colour, "", user, msg_colour, "", " has been granted access to the bot commands.")	
		elseif addcheck == "YES" then
			user = string.gsub (user, "^.", string.upper)
			ColourNote(qty_colour, "", user, msg_colour, "", " has already been granted access.")
		end
	elseif cmd == "remove" then
		addcheck = "NO"

		for i,v in pairs(EpicPermissionTable) do
			if i == user then 
				EpicPermissionTable[user] = nil
				addcheck = "YES"
				user = string.gsub (user, "^.", string.upper)
				ColourNote(qty_colour, "", user, msg_colour, "", "'s bot command access has been removed.")
				return
			end
		end
		
		if addcheck == "NO" then
			user = string.gsub (user, "^.", string.upper)
			ColourNote(qty_colour, "", user, msg_colour, "", " was not on found in access list.")
		end
	end
	
	SaveState()
end -- UserPermission

function TogglePermissions()
	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		ColourNote(msg_colour, "", "Channel commands permissions set to ", qty_colour, "", "ALL")
		EpicMisc["NotificationBot"]["Permissions"] = "all"
	elseif EpicMisc["NotificationBot"]["Permissions"] == "all" then
		ColourNote(msg_colour, "", "Channel commands permissions set to ", qty_colour, "", "LIST")
		EpicMisc["NotificationBot"]["Permissions"] = "list"
	end

	SaveState()
end -- TogglePermissions

function EnableBot()
	ColourNote(msg_colour, "", "Epic Notification Bot enabled.")
	EpicMisc["NotificationBot"]["enabled"] = true

	SaveState()

	if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
		EnableCommandBot()
	end

	if EpicMisc["NotificationBot"]["Warning"]["Enabled"] == true then
		EnableWarningBot()
	end
	
	if EpicMisc["NotificationBot"]["AutoEnabled"] == true then
		EnableAutoBot()
	end
end -- EnableBot

function DisableBot()
	ColourNote(msg_colour, "", "Epic Notification Bot disabled.")
	EpicMisc["NotificationBot"]["enabled"] = false

	SaveState()

	if EpicMisc["NotificationBot"]["CommandsEnabled"] == true then
		DisableCommandBot()
	end

	if EpicMisc["NotificationBot"]["Warning"]["Enabled"] == true then
		DisableWarningBot()
	end
	
	if EpicMisc["NotificationBot"]["AutoEnabled"] == true then
		DisableAutoBot()
	end	
end -- DisableBot

function EnableWarningBot()
	ColourNote(msg_colour, "", "Warning System Enabled. You will now be notified roughly 3 hours in advance of any upcoming epic runs.")

	check (EnableTimer ("HourlyNextEpicSilent", 1))
	check (ResetTimer ("HourlyNextEpicSilent"))
	
	GetNextEpicSilent()
end -- EnableWarningBot

function DisableWarningBot()
	ColourNote(msg_colour, "", "Warning System Disabled. You will now no longer be notified in advance of any upcoming epic runs.")

	check (EnableTimer ("HourlyNextEpicSilent", 0))
	check (EnableTimer ("NextEpic5Minutes", 0))
	check (EnableTimer ("NextEpicComingUp", 0))
end -- DisableWarningBot

function EnableAutoBot()
	ColourNote(msg_colour, "", "Auto Notifications Enabled.")
	Note("")
	ColourNote(msg_colour, "", "You will now hourly broadcast the next upcoming epic run.")
	
	check (EnableTimer ("HourlyNextEpicNotification", 1))
	check (ResetTimer ("HourlyNextEpicNotification"))	
end -- EnableAutoBot

function DisableAutoBot()
	ColourNote(msg_colour, "", "Auto Notifications Disabled.")
	Note("")
	ColourNote(msg_colour, "", "You will longer broadcast upcoming epic run.")

	check (EnableTimer ("HourlyNextEpicNotification", 0))	
end	 -- DisableAutoBot

function EnableCommandBot()
	ColourNote(msg_colour, "", "Channel Command Bot enabled and privileges set to ", qty_colour, "", string.upper(EpicMisc["NotificationBot"]["Permissions"]))
	
	if EpicMisc["NotificationBot"]["Commands"]["gt"] == true then
		EnableTrigger ("GroupChannel", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["gt"] == false then
		EnableTrigger ("GroupChannel", false)
	end
	
	if EpicMisc["NotificationBot"]["Commands"]["tell"] == true then
		EnableTrigger ("TellChannel", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["tell"] == false then
		EnableTrigger ("TellChannel", false)
	end

	if EpicMisc["NotificationBot"]["Commands"]["ft"] == true then
		EnableTrigger ("FriendChannel", true)
		EnableTrigger ("FriendChannelYou", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["ft"] == false then
		EnableTrigger ("FriendChannel", false)
		EnableTrigger ("FriendChannelYou", false)
	end

	if EpicMisc["NotificationBot"]["Commands"]["clan"] == true then
		EnableTrigger ("ClanChannel", true)
		EnableTrigger ("ClanChannelYou", true)
	elseif EpicMisc["NotificationBot"]["Commands"]["clan"] == false then
		EnableTrigger ("ClanChannel", false)
		EnableTrigger ("ClanChannelYou", false)
	end	
end -- EnableCommandBot

function DisableCommandBot()
	ColourNote(msg_colour, "", "Channel Command Bot disabled.")
	
	EnableTrigger ("GroupChannel", false)
	EnableTrigger ("TellChannel", false)
	EnableTrigger ("FriendChannel", false)
	EnableTrigger ("ClanChannel", false)
	EnableTrigger ("ClanChannelYou", false)
	EnableTrigger ("FriendChannelYou", false)
end -- DisableCommandBot

function ChannelBot(user, cmd, search, channel)	
	if search == "if1" or search == "icefall 1" then search = "icefall1" end
	if search == "if2" or search == "icefall 2" then search = "icefall2" end
	
	GetCharName()
	
	if search ~= nil and search ~= "" then 
		if cmd == "nextepic" then
			Execute("ecal next " .. search .. " " .. channel)
		elseif cmd == "listday" then
			ChannelListDay(channel, search)
		elseif cmd == "listepic" then
			if search == "note" then
				if user ~= nil then
					if user == charname then
						Send(channel .. " @R[EpicCAL] @DSorry, type @Cecal list @Dinstead of sending a note to yourself.@w")

						return
					elseif (CheckRoom()) == "no" then
						user = string.gsub (user, "^.", string.upper)
						Send(channel .. "@R[EpicCAL] @DSorry @C" .. user .. "@D, I can not complete your request at this time Reason: @CI am not in a designated note safe room. Please try again later.@w")

						return
					end

					noteuser = user
					StartPost()
				end
			else
				ChannelListEpic(channel, search)
			end
		elseif cmd == "noteremove" then
			if tonumber(search) ~= nil then
				nnum = tonumber(search)
				SendNoEcho ("board personal")
				SendNoEcho ("note remove " .. nnum)
			end
		elseif cmd == "help" then
			BotHelp(channel, user, search)
		else
			Execute("ecal " .. cmd .. " " .. search .. " " .. channel)
		end
	else
		if cmd == "nextepic" then
			Execute("ecal next epic " .. channel)
		elseif cmd == "nextleader" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D command usage is @C!nextleader <leader name>@w")			
		elseif cmd == "nextday" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D command usage is @C!nextday <day>@w")			
		elseif cmd == "listday" then
			search = nil
			ChannelListDay(channel, search)
		elseif cmd == "listepic" then
			search = nil
			ChannelListEpic(channel, search)
		elseif cmd == "noteremove" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DSorry @C" .. user .. "@D, Which note did you want me to remove?")
		elseif cmd == "help" then
			user = string.gsub (user, "^.", string.upper)
			SendNoEcho (channel .. " @R[EpicCAL] @DHello @C" .. user .. "@D, available commands: @C!nextepic@D, @C!nextday@D, @C!nextleader@D, @C!listepic@D, @C!listday @Dand @C!noteremove@D. Please see @C!help <cmd> @Dfor more information, i.e. @C!help nextepic@D.@w")
		end
	end	
end -- ChannelBot

function CheckOver(eindex)
	
	if EpicTable[eindex]["Time Table"] == nil then 
		ocheck = "YES"
		return ocheck
	elseif EpicTable[eindex]["Time Table"]["yday"] == nil then 
		ocheck = "YES"
		return ocheck
	elseif EpicTable[eindex]["Time Table"]["hour"] == nil then 
		ocheck = "YES"
		return ocheck
	elseif EpicTable[eindex]["Time Table"]["min"] == nil then 
		ocheck = "YES"
		return ocheck
	end

	epicday = EpicTable[eindex]["Time Table"]["yday"]
	epichour = EpicTable[eindex]["Time Table"]["hour"]
	epicmin = EpicTable[eindex]["Time Table"]["min"]
	sysday = SystemTimeTable["yday"]
	syshour = SystemTimeTable["hour"]
	sysmin = SystemTimeTable["min"]
	
	ocheck = "NO"
	
	if epicday < sysday then
		ocheck = "YES"
		return ocheck
	elseif epicday == sysday then
		if epichour < syshour then
			ocheck = "YES"
			return ocheck
		elseif epichour == syshour then
			if epicmin < sysmin then
				ocheck = "YES"
				return ocheck
			end
		end
	end
	
	return ocheck
end

function ChannelListDay(channel, day)

		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)
		
	if day == nil then		
		message = "@R[Full Schedule for @CToday@R] - "
		message2 = "@R[Full Schedule for @CToday@R] - "

		wday = SystemTimeTable["wday"]
	else
		echeck = "NO"

		for i, v in ipairs(DaysofWeekShort) do
			eday = v
			len = string.len(eday)

			if string.find(string.sub(day,1,len),eday) ~= nil then
				wday = i
				echeck = "YES"
			end
		end
		
		if echeck == "NO" then
			SendNoEcho (channel .. " @R[EpicCAL] @C" .. day .. " @Dis not a valid day.@w")
			return
		end

		message = "@R[Full Schedule for @C" .. day .. "@R] - "
		message2 = "@R[Full Schedule for @C" .. day .. "@R] - "	
	end
		
	daycheck = "NO"
		
	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "NO" then
			previndex = i - 1		
			
			if EpicTable[i]["Epic Name"] == "icefall1" then
				ename = "Icefall 1"
			elseif EpicTable[i]["Epic Name"] == "icefall2" then
				ename = "Icefall 2"
			elseif EpicTable[i]["Epic Name"] == "oc" then
				ename = "OC"
			else 
				ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
			end
			
			dindex = EpicTable[i]["Time Table"]["wday"]
			
			day = string.gsub (DaysofWeekShort[dindex], "^.", string.upper)
			
			if EpicTable[i]["Time Table"]["min"] ~= 0 then
				hour = EpicTable[i]["Hour"] .. ":" .. EpicTable[i]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[i]["AMPM"])
			else
				hour = EpicTable[i]["Hour"] .. ":00 " .. string.upper(EpicTable[i]["AMPM"])
			end
		
			mindex = EpicTable[i]["Time Table"]["month"]
			month = string.gsub (Months[mindex], "^.", string.upper)
			
			date = month .. " " .. EpicTable[i]["Time Table"]["day"]
    	
			if wday == dindex then
				daycheck = "YES"
				if message == message2 then
					message = message .. "@R[" .. day .. ": @C" .. ename .. " @G" .. hour
				else
					if EpicTable[i]["Time Table"]["yday"] == EpicTable[previndex]["Time Table"]["yday"] then
						message = message .. "@R/@C" .. ename .. " @G" .. hour
					else
						message = message .. "@R] [" .. day .. ": @C" .. ename .. " @G" .. hour
					end
				end
			end
		end
	end
	
	if daycheck == "YES" then
		SendNoEcho (channel .. " " .. message .. "@R]@w")
	elseif daycheck == "NO" then
		SendNoEcho (channel .. " @DThere are no epics runs scheduled or left to run on that day.@w")
	end
end -- ChannelListDay

function ChannelListEpic(channel, ltype)
	if ltype == nil then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if atime == btime then return a["Index"] < b["Index"] else return atime < btime end end)
		
		message = "@R[Full Schedule] - "
		message2 = "@R[Full Schedule] - "
	elseif ltype == "epic" then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if a["Epic Name"] == b["Epic Name"] then return atime < btime else return a["Epic Name"] < b["Epic Name"] end end)

		message = "@R[Full Schedule - Grouped by Epic Name] - "
		message2 = "@R[Full Schedule - Grouped by Epic Name] - "
	elseif ltype == "leader" then
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if a["Epic Leader"] == b["Epic Leader"] then return atime < btime elseif atime == btime then return a["Epic Leader"] < b["Epic Leader"] else return a["Index"] < b["Index"] end end)
		
		message = "@R[Full Schedule - Grouped by Leader] - "
		message2 = "@R[Full Schedule - Grouped by Leader] - "
	else
		table.sort(EpicTable, function (a, b) local atime = os.time(a["Time Table"]); local btime = os.time(b["Time Table"]); if a["Epic Name"] == b["Epic Name"] then return atime < btime  else return a["Epic Name"] < b["Epic Name"] end end)
	
		if ltype == "icefall1" then
			sepic = "Icefall 1"
		elseif ltype == "icefall2" then
			sepic = "Icefall 2"
		elseif ltype == "oc" then
			sepic = "OC"
		else 
			sepic = string.gsub (ltype, "^.", string.upper)
		end

		message = "@R[Full Schedule - Epic Names matching @C" .. sepic .. "@R] - "
		message2 = "@R[Full Schedule - Epic Names matching @C" .. sepic .. "@R] - "
		
		echeck = "NO"
		
		for i,v in ipairs(EpicTable) do
			len = string.len(ltype)

			epicname = EpicTable[i]["Epic Name"]

			if string.find(string.sub(epicname,1,len),ltype) ~= nil then
				echeck = "YES"
			end
		end
		
		if echeck == "NO" then
			SendNoEcho (channel .. " @R[EpicCAL] @DNo @C" .. ltype .. " @Depic runs scheduled.@w")
			return
		end
	end
	
	for i,v in ipairs(EpicTable) do
		if CheckOver(i) == "NO" then
			previndex = i - 1		
			
			if EpicTable[i]["Epic Name"] == "icefall1" then
				ename = "Icefall 1"
			elseif EpicTable[i]["Epic Name"] == "icefall2" then
				ename = "Icefall 2"
			elseif EpicTable[i]["Epic Name"] == "oc" then
				ename = "OC"
			else 
				ename = string.gsub (EpicTable[i]["Epic Name"], "^.", string.upper)
			end
			
			dindex = EpicTable[i]["Time Table"]["wday"]
			
			day = string.gsub (DaysofWeekShort[dindex], "^.", string.upper)
			
			if EpicTable[i]["Time Table"]["min"] ~= 0 then
				hour = EpicTable[i]["Hour"] .. ":" .. EpicTable[i]["Time Table"]["min"] .. " " ..  string.upper(EpicTable[i]["AMPM"])
			else
				hour = EpicTable[i]["Hour"] .. ":00 " .. string.upper(EpicTable[i]["AMPM"])
			end
		
			mindex = EpicTable[i]["Time Table"]["month"]
			month = string.gsub (Months[mindex], "^.", string.upper)
			
			date = month .. " " .. EpicTable[i]["Time Table"]["day"]
    	
			if ltype == nil then
				if message == message2 then
					message = message .. "@R[" .. day .. ": @C" .. ename .. " @G" .. hour
				else
					if EpicTable[i]["Time Table"]["yday"] == EpicTable[previndex]["Time Table"]["yday"] then
						message = message .. "@R/@C" .. ename .. " @G" .. hour
					else
						message = message .. "@R] [" .. day .. ": @C" .. ename .. " @G" .. hour
					end
				end
			elseif ltype == "epic" then
				if message == message2 then
					message = message .. "@R[" .. ename .. ": @C" .. day .. " (" .. date .. ") @R- @G" .. hour
				else
					if EpicTable[i]["Epic Name"] == EpicTable[previndex]["Epic Name"] then
						message = message .. "@R/@C" .. day .. " (" .. date .. ") @R- @G" .. hour
					else
						message = message .. "@R] [" .. ename .. ": @C" .. day .. " (" .. date .. ") @R- @G" .. hour
					end
				end
			elseif ltype == "leader" then
				leader = string.gsub (EpicTable[i]["Epic Leader"], "^.", string.upper)
			
				if message == message2 then
					message = message .. "@R[" .. leader .. ": @C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @R- @G" .. hour
				else
					if EpicTable[i]["Epic Leader"] == EpicTable[previndex]["Epic Leader"] then
						message = message .. "@R/@C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @R- @G" .. hour
					else
						message = message .. "@R] [" .. leader .. ": @C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @R- @G" .. hour
					end
				end
			else
				len = string.len(ltype)

				epicname = EpicTable[i]["Epic Name"]
				
				if string.find(string.sub(epicname,1,len),ltype) ~= nil then
					if message == message2 then
						message = message .. "@R[@C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @G" .. hour
					else 
						message = message .. "@R] [@C" .. ename .. " @R- @Y" .. day .. " (" .. date .. ") @G" .. hour
					end
				end
			end
		end
	end
	
	SendNoEcho (channel .. " " .. message .. "@R]@w")
end -- ChannelListEpic

function DelayOn(user, channel)
	user = string.gsub (user, "^.", string.upper)
	
	SendNoEcho (channel .. " @R[EpicCAL] @DSorry @R" .. user .. "@D, but I am unable to process your request at this time. Reason: 5 second delay to prevent error.")
end -- DelayOn

function TellChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	search = string.lower(wc[3])
	channel = "tell " .. user

	GetCharName()

	if user ~= charname then 
		if EpicMisc["NotificationBot"]["Permissions"] == "list" then
			if (CheckPermission(user)) == "no" then
				return
			end
		end
	
		if TellChannelDelay == false then
			TellDelayEnable()
		
			ChannelBot(user, cmd, search, channel)
		else
			DelayOn(user, channel)
		end
	else
		ChannelBot(user, cmd, search, channel)
	end
end -- TellChannel

function ClanChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	search = string.lower(wc[3])
	channel = "clan"
	
	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			return
		end
	end

	if ClanChannelDelay == false then
		ClanDelayEnable()
	
		ChannelBot(user, cmd, search, channel)
	else
		DelayOn(user, channel)
	end
end -- ClanChannel

function ClanChannelYou(name, line, wc)
	GetCharName()
	user = charname
	cmd = string.lower(wc[1])
	search = string.lower(wc[2])
	channel = "clan"
	
	ChannelBot(user, cmd, search, channel)
end -- ClanChannelYou

function GroupChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	if wc[3] == nil then 
		search = nil
	else
		search = string.lower(wc[3])
	end
	
	channel = "gt"

	GetCharName()

	if user ~= charname then 
		if EpicMisc["NotificationBot"]["Permissions"] == "list" then
			if (CheckPermission(user)) == "no" then
				return
			end
		end
	
		if GroupChannelDelay == false then
			GroupTellDelayEnable()
		
			ChannelBot(user, cmd, search, channel)
		else
			DelayOn(user, channel)
		end
	else
		ChannelBot(user, cmd, search, channel)
	end
end -- GroupChannel

function FriendChannel(name, line, wc)
	user = string.lower(wc[1])
	cmd = string.lower(wc[2])
	search = string.lower(wc[3])
	channel = "ft"
	
	if EpicMisc["NotificationBot"]["Permissions"] == "list" then
		if (CheckPermission(user)) == "no" then
			return
		end
	end

	if FriendChannelDelay == false then
		FriendTalkDelayEnable()
	
		ChannelBot(user, cmd, search, channel)
	else
		DelayOn(user, channel)
	end
end -- FriendChannel

function FriendChannelYou(name, line, wc)
	GetCharName()
	user = charname
	cmd = string.lower(wc[1])
	search = string.lower(wc[2])
	channel = "ft"
	
	ChannelBot(user, cmd, search, channel)
end -- FriendChannelYou

-- Channel Command Delay Functions

function ClanDelayDisable()
	check (EnableTimer ("clandelay", 0))
	ClanChannelDelay = false
end -- ClanDelayDisable

function GroupTellDelayDisable()
	check (EnableTimer ("gtdelay", 0))
	GroupChannelDelay = false
end -- GroupTellDelayDisable

function FriendTalkDelayDisable()
	check (EnableTimer ("ftdelay", 0))
	FriendChannelDelay = false
end -- FriendTalkDelayDisable

function TellDelayDisable()
	check (EnableTimer ("telldelay", 0))
	TellChannelDelay = false
end -- TellDelayDisable

function ClanDelayEnable()
	check (EnableTimer ("clandelay", 1))
	check (ResetTimer ("clandelay"))
	ClanChannelDelay = true
end -- ClanDelayEnable

function GroupTellDelayEnable()
	check (EnableTimer ("gtdelay", 1))
	check (ResetTimer ("gtdelay"))
	GroupChannelDelay = true
end -- GroupTellDelayEnable

function FriendTalkDelayEnable()
	check (EnableTimer ("ftdelay", 1))
	check (ResetTimer ("ftdelay"))
	FriendChannelDelay = true
end -- FriendTalkDelayEnable

function TellDelayEnable()
	check (EnableTimer ("telldelay", 1))
	check (ResetTimer ("telldelay"))
	TellChannelDelay = true
end -- TellDelayEnable

function EnableNextEpicNotification(index, time)
	NextEpicNotification = index
	
	hour = time["hour"]
	min = time["min"]
	sec = 0
	
	min = min - 5
	
	if min < 0 then
		min = min + 60
		hour = hour - 1
	end

	day = GetLowestDay(index)				

	SetTimerOption ("NextEpic5Minutes", "hour", hour)
	SetTimerOption ("NextEpic5Minutes", "minute", min)
	SetTimerOption ("NextEpic5Minutes", "second", sec)
	check (EnableTimer ("NextEpic5Minutes", 1))
	check (ResetTimer ("NextEpic5Minutes"))

	NextEpicComingUp()	

	check (EnableTimer ("NextEpicComingUp", 1))
	check (ResetTimer ("NextEpicComingUp"))
	
	check (EnableTimer ("HourlyNextEpicSilent", 0))
end -- EnableNextEpicNotification

function HourlyNextEpicSilent()
	GetNextEpicSilent()
end -- HourlyNextEpicSilent

function NextEpicComingUp()
	ReturnType = "normal"
	timeremaining = EpicTimeDifference(NextEpicNotification, ReturnType)

	ColourNote("red", "" , "[" .. EpicTable[NextEpicNotification]["Epic Name"] .. " epic]", msg_colour, "" , " starting in ", help_command_colour, "", trim(timeremaining))
end -- NextEpicComingUp

function NextEpic5Minutes()
	ColourNote("red", "" , "[" .. EpicTable[NextEpicNotification]["Epic Name"] .. " Epic]", msg_colour, "" , " starting in ", help_command_colour, "", "5", msg_colour, "", " minutes.")
	check (EnableTimer ("NextEpic5Minutes", 0))
	check (EnableTimer ("NextEpicComingUp", 0))
	
	check (EnableTimer ("HourlyNextEpicSilent", 1))
	check (ResetTimer ("HourlyNextEpicSilent"))
end -- NextEpic5Minutes

function HourlyNextEpicNotification()
	for i,v in pairs(EpicMisc["NotificationBot"]["Auto"]) do
		if v == true then
			Execute("ecal next epic " .. i)
		end
	end
end -- HourlyNextEpicNotification
 
-----------------------------------------------
-------------- UTILITY FUNCTIONS --------------
-----------------------------------------------
function GetSystemTime()
	world.EnableGroup("SystemTime", 1)
	SendNoEcho ("real time")
end -- GetSystemTime

function GetSystemTimeTrig(name, line, wc)
	mday = tonumber(wc[5])
	year = tonumber(wc[7])

	day = string.lower(wc[4])
	month = string.lower(wc[6])
	
	for i,v in ipairs(DaysofWeek) do
		if DaysofWeek[i] == day then
			wday = i
		end
	end

	for i,v in ipairs(Months) do
		if Months[i] == month then
			wmon = i
		end
	end
	
	for j,u in ipairs(MonthsYDay) do
		if j == wmon then
			yday = MonthsYDay[j]
		end
	end

	yday = yday + mday	
	
	if (year%4) == 0 then yday = yday + 1 end
	
    SystemTimeTable = {
      month = wmon,
      wday = wday,
      yday = yday,
      day = mday,
      min = tonumber(wc[2]),
      sec = tonumber(wc[3]),
      hour = tonumber(wc[1]),
      year = year,
      }
	
	world.EnableGroup("SystemTime", 0)

	if listtype == "next" then  
		NextEpic()
	elseif listtype == "none" then
	elseif listtype == "permissions" then
		ListPermissions()
	elseif listtype == "post" then
		StartNotePost()
	else
		ListEpic()
	end	
end -- GetSystemTimeTrig

function EpicTimeDifference(TableIndex, ReturnType)	
	timenow = os.time(SystemTimeTable)
	timenow2 = os.time(EpicTable[TableIndex]["Time Table"])
	
	if timenow > timenow2 then
		--- insert over message stuff here
	else
		timediff2 = {}
		timeDiff(timenow2,timenow,timediff2)

		if ReturnType == "normal" then
			local rtime = remainingtime_note(timediff2)
			return rtime
		elseif ReturnType == "table" then
			return timediff2
		end
	end	
end -- EpicTimeDifference

-- FUNCTION TO CALCULATION DIFFERENCE BETWEEN TWO TIMES --
function timeDiff(t2,t1,script)
    local d1,d2,carry,diff = os.date('*t',t1),os.date('*t',t2),false,{}

	tprint(diff)
    local colMax = {60,60,24,os.date('*t',os.time{year=d1.year,month=d1.month+1,day=0}).day,12}
    d2.hour = d2.hour - (d2.isdst and 1 or 0) + (d1.isdst and 1 or 0) -- handle dst
    for i,v in ipairs({'sec','min','hour','day','month','year'}) do
        diff[v] = d2[v] - d1[v] + (carry and -1 or 0)
        carry = diff[v] < 0
        if carry then diff[v] = diff[v] + colMax[i] end
    end
    for i,v in pairs(diff) do
        script[i] = v
    end
    return diff
end -- timeDiff

function MakeSpace(title, maxleng)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(maxleng)
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
	end

	spacing = string.rep(" ", lendif)
	return spacing
end -- MakeSpace

function HelpSpacing(title, title2)
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	local spacing = 0
	local lendif = 0
	
	if leng > leng2 then
	else
		lendif = leng2 - leng
		lendif = lendif * 0.5
	end

	spacing = string.rep(" ", lendif)
	
	return spacing
end -- HelpSpacing

function remainingtime_note(time)
	remaining_time = ""

	if time["year"] ~= nil then
		if tonumber(time["year"]) == 1 then
			remaining_time = time["year"] .. " year  "
		elseif tonumber(time["year"]) ~= 0 then
			remaining_time = time["year"] .. " years "
		end
	end

	ttype = "month"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "day"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
	ttype = "hour"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)

	ttype = "min"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)

	ttype = "sec"
	remaining_time = GetTimeMessage(time, ttype, remaining_time)
	
    return(remaining_time)
end -- remainingtime_note

function GetTimeMessage(time, ttype, remaining_time)
	if remaining_time == nil then
		remaining_time = ""
	end

	if time[ttype] ~= nil then
		if tonumber(time[ttype]) == 1 then
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. " "
		elseif tonumber(time[ttype]) ~= 0 then
			remaining_time = remaining_time .. time[ttype] .. " " .. ttype .. "s "
		end
	end
	
	return (remaining_time)
end -- GetTimeMessage

function TimeToSeconds(tablename)
	local seconds = 0

	if tablename["year"] >= 0 then
		seconds = (tablename["year"] * 31536000)
	end

	if tablename["month"] >= 0 then
		seconds = (tablename["month"] * 2592000) + seconds
	end

	if tablename["day"] >= 0 then
		seconds = (tablename["day"] * 86400) + seconds
	end
		
	if tablename["hour"] >= 0 then
		seconds = (tablename["hour"] * 3600) + seconds
	end

	if tablename["min"] >= 0 then
		seconds = (tablename["min"] * 60) + seconds
	end

	if tablename["sec"] >= 0 then	
		seconds = tablename["sec"] + seconds
	end

    return(seconds)
end -- TimeToSeconds

function SeperateDate(dateonly)	
	EpicTable[TableIndex]["Time Table"] = {}
	
	for date in dateonly:gmatch("%a%a%a") do
		for i,v in ipairs (Months) do
			if Months[i] == date then
				EpicTable[TableIndex]["Time Table"]["month"] = i
			end
		end
	end
	
	for date in dateonly:gmatch("%d%d") do
		EpicTable[TableIndex]["Time Table"]["day"] = tonumber(date)
	end
end -- SeperateDate

function SeperateTime(timeonly)
	len = string.len(timeonly)
	
	if len == 3 or len == 4 then
	
		for hour in timeonly:gmatch("%d+") do
			EpicTable[TableIndex]["Hour"] = tonumber(hour)
		end
		
		EpicTable[TableIndex]["Minute"] = 0
	elseif len == 5 or len == 6 then
		st1 = timeonly:gsub("%d%d[ap]m", "----")

		for hour in st1:gmatch("%d+") do EpicTable[TableIndex]["Hour"] = tonumber(hour) end

		for min in timeonly:gmatch("%d%d[ap]m") do
			st2 = min:gsub("[ap]m", "--")
			for st3 in st2:gmatch("%d+") do EpicTable[TableIndex]["Minute"] = tonumber(st3) end
		end	
	end
end -- SeperateTime

function NoteRoom(cmd)
	if cmd == "add" then
		AddRoom()
	elseif cmd == "remove" then
		RemoveRoom()
	end
end -- NoteRoom

function AddRoom()
	GetRoom()
	
	if EpicMisc["NoteRooms"][gmcproomid] == nil then
		EpicMisc["NoteRooms"][gmcproomid] = {}
		EpicMisc["NoteRooms"][gmcproomid]["Name"] = gmcpname
		EpicMisc["NoteRooms"][gmcproomid]["Area"] = gmcparea
		
		ColourNote("red", "", "[" .. gmcparea, msg_colour, "", "/", "red", "", gmcpname, msg_colour, "", "/", "red", "", gmcproomid .. "]", msg_colour, "", " has been added to database")
		SaveState()
	else
		ColourNote("red", "", "[" .. gmcparea, msg_colour, "", "/", "red", "", gmcpname, msg_colour, "", "/", "red", "", gmcproomid .. "]", msg_colour, "", " has already been added to database")
	end
end -- AddRemove

function RemoveRoom()
	GetRoom()
	
	if EpicMisc["NoteRooms"][gmcproomid] ~= nil then
		EpicMisc["NoteRooms"][gmcproomid] = nil
		
		ColourNote("red", "", "[" .. gmcparea, msg_colour, "", "/", "red", "", gmcpname, msg_colour, "", "/", "red", "", gmcproomid .. "]", msg_colour, "", " has been removed from database")
		SaveState()
	else
		ColourNote("red", "", "[" .. gmcparea, msg_colour, "", "/", "red", "", gmcpname, msg_colour, "", "/", "red", "", gmcproomid .. "]", msg_colour, "", " is not in the database")
	end
end -- RemoveRoom

function GetRoom()
	Send_GMCP_Packet("request room")

	gmcparea = gmcp("room.info.zone")
	gmcproomid = tonumber(gmcp("room.info.num"))
	gmcpname = gmcp("room.info.name")
end -- GetRoom

function ListRooms()
	title = "Note Posting Safe Room List"

	local title2 = "+-------+------------------------------------------+-------------------------------------+"
	
	local leng = tonumber(string.len(title))
	local leng2 = tonumber(string.len(title2))
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	Note("")

	ColourNote(msg_colour, "", title2)
	ColourNote(msg_colour, "", "| Room# | Room Name                                | Area name                           |")
	ColourNote(msg_colour, "", title2)

	for i,v in pairs(EpicMisc["NoteRooms"]) do

		roomnum = i
		roomname = EpicMisc["NoteRooms"][i]["Name"]
		areaname =  nil

		for j,k in pairs(AreaNames) do 
			if EpicMisc["NoteRooms"][i]["Area"] == j then
				areaname = k
			end
		end
		
		if areaname == nil then areaname = EpicMisc["NoteRooms"][i]["Area"] end

		if roomname == nil then rnamespace = 40 else rnamespace = MakeSpace(roomname, 40) end
	
		if areaname == nil then areaspace = 35 else areaspace = MakeSpace(areaname, 35) end

		ColourNote(msg_colour, "", "| ", epic_colour, "", roomnum, msg_colour, "", " | ", leader_colour, "", roomname .. rnamespace, msg_colour, "", " | ", remain_colour, "", areaname .. areaspace, msg_colour, "", " |")
	end

	ColourNote(msg_colour, "", title2)
end -- ListRooms

function GetCharName()
	gmcpbase = gmcp("char.base") -- fetch char.status and return it as a Lua table
	charname = string.lower(gmcpbase.name)
end -- GetCharName

---------------------------------------------
--------------- HELP FUNCTION ---------------
---------------------------------------------
function EpicCalendarHelp()	
	local title = "Tallimos' Epic Calendar v" .. PLUGIN_VERSION .. " Help"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", title)
	ColourNote(help_colour, "", noteline)
	ColourNote(help_colour, "", "This plugin gives the user an easy way of keeping track of upcoming epic runs as well as some")
	ColourNote(help_colour, "", "nice few extras. Once installed the user can use the commands below to update the list. Also")
	ColourNote(help_colour, "", "if a note is posted while the user is online the list will automatically get updated.")
	ColourNote(help_colour, "", noteline)
	Note("")
	
	ColourNote(help_colour, "", "Main Commands")
	ColourNote(help_colour, "", "-------------")
	
	ColourNote(help_command_colour, "", "ecal update  ", help_colour, "", " - checks and see if the latest version of the plugin is installed")

	
	ColourNote(help_command_colour, "", "ecal reset   ", help_colour, "", " - clears the epic run list and adds all upcoming runs")

	ColourNote(help_command_colour, "", "ecal clear   ", help_colour, "", " - clears the epic run list without adding upcoming runs")

	ColourNote(help_command_colour, "", "ecal list    ", help_colour, "", " - lists all upcoming epic runs")

	ColourNote(help_command_colour, "", "ecal nupdate <note #>", help_colour, "", " - used when epic leader posts a subject line to long")
	
	ColourNote(help_command_colour, "", "ecal checkversion    ", help_colour, "", " - checks to see if there is a newer version of the plugin available")
	
	ColourNote(help_command_colour, "", "ecal changelog       ", help_colour, "", " - displays the changelog for the plugin")

	ColourNote(help_command_colour, "", "ecal search <epic>   ", help_colour, "", " - searches the epic runs list")
	Note("")
	
	ColourNote(help_colour, "", "Other Features")
	ColourNote(help_colour, "", "--------------")

	ColourNote(help_command_colour, "", "ecal help bot ", help_colour, "", " - for more information on a notification and channel command bot")

	ColourNote(help_command_colour, "", "ecal help next", help_colour, "", " - for more information on some useful commands to display the next upcoming epic")
	Note("")
	
	ColourNote(help_command_colour, "", "PLEASE NOTE", help_colour, "", ": the user can also use ", help_command_colour, "", "epiccalendar", help_colour, "", " instead of ", help_command_colour, "", "ecal")
	
	ColourNote(help_colour, "", noteline)
	Note("")
end	-- EpicCalendarHelp

function EpicCalendarHelpBot()	
	local title = "Tallimos' Epic Calendar Help - Notification Bot"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)	
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", "Tallimos' Epic Calendar Help - Notification Bot")
	ColourNote(help_colour, "", noteline)
	ColourNote(help_colour, "", "The notification bot allows the user to warn themselves of upcoming epic runs. If an is going")
	ColourNote(help_colour, "", "to start within 3 hours or less the system will remind the user every hour of the upcoming epic")
	ColourNote(help_colour, "", "run as well as a 5 minute notice of it starting.")
	Note("")
	ColourNote(help_colour, "", "Also with this system the user can grant whoever they want access to " , qty_colour, "", "next", help_colour, "", " commands without")
	ColourNote(help_colour, "", "having to install the plugin themselves. See ", help_command_colour, "", "ecal help next", help_colour, "", " for more information on those")
	ColourNote(help_colour, "", "commands.")
	Note("")
	ColourNote(help_colour, "", "Finally this system will also allow users to post hourly reminders to channels of their")
	ColourNote(help_colour, "", "choosing of the next up coming epic run.")
	ColourNote(help_colour, "", noteline)

	ColourNote(help_command_colour, "", "ecal bot <enable|disable>    ", help_colour, "", " - enables/disables the main bot system")

	ColourNote(help_command_colour, "", "ecal bot <add|remove> <user> ", help_colour, "", " - add/removes users to the channel command permission system")

	ColourNote(help_command_colour, "", "ecal bot plist               ", help_colour, "", " - list all users who have access to the channel commands")

	ColourNote(help_command_colour, "", "ecal bot permissions         ", help_colour, "", " - toggles channel command access between ", qty_colour, "", "LIST", help_colour, "", " and ", qty_colour, "", "ALL", help_colour, "", ". default is")
	ColourNote(help_colour, "", "                                set to ", qty_colour, "", "LIST")

	ColourNote(help_command_colour, "", "ecal bot <auto|commands> list", help_colour, ""," - lists the channels and their settings for the specified system")

	ColourNote(help_command_colour, "", "ecal bot <auto|commands|warning> <enable|disable>  ", help_colour, "", " - enables/disables the specified system")

	ColourNote(help_command_colour, "", "ecal bot <auto|commands> <enable|disable> <channel>", help_colour, "", " - enables/disables the channel notification")
	ColourNote(help_colour, "", "                                                      in the specified system")

	ColourNote(help_command_colour, "", "ecal bot auto <add|remove> <channel>", help_colour, "", " - adds/removes channels to the auto notification list")

	ColourNote(help_command_colour, "", "ecal bot <add|remove> room", help_colour, "", " - adds/removes the current room to the approved note sending")
	ColourNote(help_colour, "", "                             room list")

	ColourNote(help_command_colour, "", "ecal bot list room        ", help_colour, "", " - displays the list of approved note sending rooms")
	Note("")
	
	ColourNote(help_command_colour, "", "PLEASE NOTE", help_colour, "", ": only ", qty_colour, "", "ft", help_colour, "", ", ", qty_colour, "", "gt", help_colour, "", ", ", qty_colour, "", "clan", help_colour, "", " and ", qty_colour, "", "tells", help_colour, "", " have been added to the channel command system")

	ColourNote(help_colour, "", noteline)
	Note("")
end	-- EpicCalendarHelpBot

function EpicCalendarHelpNext()	
	local title = "Tallimos' Epic Calendar Help - Next Commands"
	local title2 = noteline
	
	spacing = HelpSpacing(title, title2)
	
	ColourNote(help_colour, "", spacing, help_command_colour, "", "Tallimos' Epic Calendar Help - Next Commands")
	ColourNote(help_colour, "", noteline)
	ColourNote(help_colour, "", "The next commands are basically just that, it will show the next epic coming up in various")
	ColourNote(help_colour, "", "categories.")
	ColourNote(help_colour, "", noteline)

	ColourNote(help_command_colour, "", "ecal nextepic            ", help_colour, "", " - displays to the user which epic run is coming up next")

	ColourNote(help_command_colour, "", "ecal nextepic <epic>     ", help_colour, "", " - displays when the next specified epic run is coming up")

	ColourNote(help_command_colour, "", "ecal nextday <day>       ", help_colour, "", " - displays the first epic run on a particular day")

	ColourNote(help_command_colour, "", "ecal nextleader <leader> ", help_colour, "", " - displays the next epic run coming up for a particular leader")
	Note("")
	
	ColourNote(help_colour, "", "If the user specifies a channel in the above commands then the message will get displayed to")
	ColourNote(help_colour, "", "that channel. For example '", help_command_colour, "", "ecal nextepic inferno ft", help_colour, "", "' will display the next schedule inferno")
	ColourNote(help_colour, "", "epic run to friend talk. ", help_command_colour, "", "Take Note", help_colour, "", " - to display the next upcoming epic to a channel the user")
	ColourNote(help_colour, "", "must use ", help_command_colour, "", "ecal nextepic epic <channel>")
	Note("")
	
	ColourNote(help_colour, "", "Channel Command System")
	ColourNote(help_colour, "", "----------------------")
	ColourNote(help_colour, "", "If the channel command system has been activated the users who have access can using the")
	ColourNote(help_colour, "", "commands below to see upcoming epic runs")
	Note("")
	
	ColourNote(help_command_colour, "", "!nextepic            ", help_colour, "", " - displays the next upcoming epic")

	ColourNote(help_command_colour, "", "!nextepic <epic>     ", help_colour, "", " - displays when the next specified epic is scheduled")
	
	ColourNote(help_command_colour, "", "!nextday <day>       ", help_colour, "", " - displays the first epic of the day on that particular day")
	
	ColourNote(help_command_colour, "", "!nextleader <leader> ", help_colour, "", " - displays the first epic scheduled for that particular leader")

	ColourNote(help_command_colour, "", "!listepic            ", help_colour, "", " - displays the entire epic schedule on one line, sorted by day")

	ColourNote(help_command_colour, "", "!listepic leader     ", help_colour, "", " - displays the entire epic schedule on one line, grouped by leader")

	ColourNote(help_command_colour, "", "!listepic epic       ", help_colour, "", " - displays the entire epic schedule on one line, sorted by epic name")

	ColourNote(help_command_colour, "", "!listepic <epic name>", help_colour, "", " - displays the full schedule of the epic the user searched for")

	ColourNote(help_command_colour, "", "!listepic note       ", help_colour, "", " - will request the bot to send them the schedule via a note")

	ColourNote(help_command_colour, "", "!noteremove <notenum>", help_colour, "", " - will request the bot to remove the schedule note")

	ColourNote(help_colour, "", noteline)
	Note("")
end	-- EpicCalendarHelpNext

function GetSavedData()
	if GetVariable ("ecpastfirstinstall") == "true" then
		assert (loadstring (GetVariable ("EpicTable") or "")) ()
		assert (loadstring (GetVariable ("EpicPermissionTable") or "")) ()
		assert (loadstring (GetVariable ("EpicMisc") or "")) ()
		assert (loadstring (GetVariable ("TableIndex") or "")) ()
	else
		TableIndex = 0
		EpicTable = {}
		EpicMisc = {}
		EpicMisc["Updating"] = "NO"
		EpicMisc["NoteRooms"] = {}
		EpicMisc["NoteRooms"][32418] = {}
		EpicMisc["NoteRooms"][32418]["Area"] = "aylor"
		EpicMisc["NoteRooms"][32418]["Name"] = "The Grand City of Aylor"
		EpicMisc["NotificationBot"] = {}
		EpicMisc["NotificationBot"]["Enabled"] = false
		EpicMisc["NotificationBot"]["Commands"] = {}
		EpicMisc["NotificationBot"]["CommandsEnabled"] = false
		EpicMisc["NotificationBot"]["Commands"]["gt"] = false
		EpicMisc["NotificationBot"]["Commands"]["tell"] = false
		EpicMisc["NotificationBot"]["Commands"]["clan"] = false
		EpicMisc["NotificationBot"]["Commands"]["ft"] = false
		EpicMisc["NotificationBot"]["Permissions"] = "list"
		EpicMisc["NotificationBot"]["AutoEnabled"] = false
		EpicMisc["NotificationBot"]["Auto"] = {}
		EpicMisc["NotificationBot"]["Auto"]["gt"] = false
		EpicMisc["NotificationBot"]["Auto"]["clan"] = false
		EpicMisc["NotificationBot"]["Auto"]["ft"] = false
		EpicMisc["NotificationBot"]["Warning"] = {}
		EpicMisc["NotificationBot"]["Warning"]["Enabled"] = false
		EpicPermissionTable = {}
	end

	ClanChannelDelay = false
	FriendChannelDelay = false
	GroupChannelDelay = false
	TellChannelDelay = false

	SaveState()
end -- GetSavedData

function Connected()
	ran = true
	
	if EpicMisc["NotificationBot"]["Enabled"] == true then EnableBot() end
	ResetEpicTable()
end -- Connected

function OnPluginInstall()
	PLUGIN_VERSION  = GetPluginInfo(GetPluginID(), 19)
	PLUGIN_NAME   = GetPluginInfo(GetPluginID(), 1)

	GetSavedData()	

	if EpicMisc["Updating"] == "YES" then
		EpicMisc["Updating"] = "NO"
		ColourNote(msg_colour, "", "Update complete.")
	elseif EpicMisc["Updating"] == "NO" then
		ColourNote(msg_colour, "", "Thank you for installing ", qty_colour, "", "Tallimos' Epic Calendar v" ..  PLUGIN_VERSION, msg_colour, "", ". Please see ", help_command_colour, "", "ecal help", msg_colour, "", " for more information.")
	end
	
	Note("")

	if IsConnected() then
		if not ran then Connected() end
	end
end -- OnPluginInstall

function OnPluginEnable()
	GetSavedData()	

	if IsConnected() then
		if not ran then Connected() end
	end
end -- OnPluginEnable

function OnPluginSaveState()
	SetVariable ("EpicTable", "EpicTable = " .. serialize.save_simple (EpicTable))
	SetVariable ("EpicPermissionTable", "EpicPermissionTable = " .. serialize.save_simple (EpicPermissionTable))
	SetVariable ("EpicMisc", "EpicMisc = " .. serialize.save_simple (EpicMisc))
	SetVariable ("TableIndex", "TableIndex = " .. serialize.save_simple (TableIndex))
	SetVariable ("ecpastfirstinstall", "true")
end -- OnPluginSaveState

function OnPluginBroadcast(msg, id, name, text)
	if id == "3e7dedbe37e44942dd46d264" then
		if text == "char.status" then
			local s = gmcp("char.status.state")
			if not ran then
				if s == "3" or s == "11" then
					Connected()
				end
			end
		end
	end
end -- OnPluginBroadcast

-- Update code taken from Pwar's installer menu
function ecal_install(name, line, wc)
   for p = 1, #pluginList do
      if pluginList[p] ~= nil and tonumber(wc.index) == p then
         printmsg("Attempting to install plugin #" .. wc.index .. " (" .. pluginList[p].name .. ")")
         install_plugin(pluginList[p])
      end
   end
   if #pluginList == 0 then
      printmsg("Error: Unable to read plugin index.")
   end
end

function ecal_update(name, line, wc)
	printmsg("*** Checking if update is available for Tallimos' Epic Calendar.. Please wait.\r\n\r\n")
	local url = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicCalendar/Tallimos_EpicCalendar.xml"
	async.doAsyncRemoteRequest(url, async_ecal_download_complete, "HTTPS", 120)
end

function async_ecal_download_complete(retval, page, status, headers, full_status, request_url)
  if status == 200 then
    local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
    local installedVer = GetPluginInfo(GetPluginID(), 19)
    if version > installedVer then
      printmsg("Updating from version " .. installedVer .. " to version " .. version)
      local file = io.open(GetPluginInfo(GetPluginID(), 6), "w")
      page = string.gsub(page, "\r", "")
      file:write(page)
      file:close()
      if GetAlphaOption("script_prefix") == "" then SetAlphaOption("script_prefix", "\\\\\\") end
      Execute(GetAlphaOption("script_prefix").."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
    else
      printmsg("You already have the latest version of Tallimos' Epic Calendar installed.")
    end
  else
      printmsg("Plugin update check failed...Error " .. tostring(status))
  end
end

function async_plugin_download_complete(retval, page, status, headers, full_status, request_url)
   local folder
   local xmlFiles = {}
   local xmlFile = {}
   if updatePlugin.installpath == "1" then
      folder = GetInfo(66)
   else
      folder = GetPluginInfo(GetPluginID(), 20)
   end
   --print("FOLDER IS " .. folder)
   if status == 200 then -- download successful
      printmsg("----------------------------------------------")
      printmsg("*** " .. updatePlugin.name .. " download successful.")
      f = assert(io.open (folder .. "temp_update.zip", "wb"))
      f:write(page)
      f:close()
      local zfile, err = zip.open(folder .. "temp_update.zip")
      printmsg("Extracting files from zip:")
      for file in zfile:files() do
         local currFile, err = zfile:open(file.filename)
         local currFileContents = currFile:read("*a") -- read entire contents of current file
         local hBinaryOutput = io.open(folder .. file.filename, "wb")
          -- write current file inside zip to a file outside zip
          if(hBinaryOutput)then
              hBinaryOutput:write(currFileContents)
              hBinaryOutput:close()
          end
         printmsg("(+) " .. file.filename)
         local fileExt = string.sub(file.filename, -4)
         if fileExt == ".xml" then
            xmlFile.filename = file.filename
            --print(xmlFile.filename)
            xmlFile.pluginid = string.match(currFileContents, '%s%s+id="(.-)"')            
            table.insert(xmlFiles, xmlFile)
            xmlFile = {}
         end
         currFile:close()
      end
      os.remove(folder .. "temp_update.zip")
      printmsg("Update succeeded, loading/reloading plugins.")
      printmsg("----------------------------------------------")
      for i = 1, #updatePlugin.ids do
         --if not IsPluginInstalled(thisPlugin.ids[i]) then
            --LoadPlugin(folder ..  
         --end
         --(IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
         --ReloadPlugin(updatePlugin.ids[i])
      end
      for i = 1, #xmlFiles do
         --print(xmlFiles[i].filename, xmlFiles[i].pluginid)
         --local version = tonumber(string.match(page, '%s%s+version="([0-9%.]+)"'))
         if not (IsPluginInstalled(xmlFiles[i].pluginid) and GetPluginInfo(xmlFiles[i].pluginid, 17)) then
            LoadPlugin(folder .. xmlFiles[i].filename)
         else
            ReloadPlugin(xmlFiles[i].pluginid)
         end
         installedPlugins[xmlFiles[i].pluginid] = headers["etag"]
      end
      SaveState()
   else
      printmsg("Plugin download failed...Error " .. tostring(status))
      --printmsg(headers["location"])
   end
   updatePlugin = {}
   xmlFiles = {}
end

function async_xml_download_complete(retval, page, status, headers, full_status, request_url)
   if status == 200 then
      --print(page)
      --print(status)
      lastListHash = headers["etag"]
      SaveState()
      local xml = utils.xmlread(page)
      local num_plugins = #xml.nodes [2].nodes
      --print(num_plugins)
      pluginList = {}
      for p = 1,num_plugins do
         num_plugin_nodes = #xml.nodes [2].nodes [p].nodes
         local thisPlugin = {}
         thisPlugin.ids = {}
         for n = 1, num_plugin_nodes do
            local xmlkey = xml.nodes [2].nodes [p].nodes [n].name
            local xmlval = xml.nodes [2].nodes [p].nodes [n].content
            if xmlkey == "name" then thisPlugin.name = xmlval
            elseif xmlkey == "author" then thisPlugin.author = xmlval
            elseif xmlkey == "description" then thisPlugin.description = xmlval
            elseif xmlkey == "id" then table.insert(thisPlugin.ids, xmlval)
            elseif xmlkey == "download" then thisPlugin.download = xmlval
            elseif xmlkey == "installpath" then thisPlugin.installpath = xmlval
            end
         end
         require "tprint"
         pluginList[p] = thisPlugin
         thisPlugin.installed = true
         for i = 1, #thisPlugin.ids do
            if not (IsPluginInstalled(thisPlugin.ids[i]) and GetPluginInfo(thisPlugin.ids[i], 17)) then
               thisPlugin.installed = false
               --print("Plugin not installed and enabled!!" .. thisPlugin.ids[i])
            end
         end
      end
      lastPluginList = pluginList
      SaveState()
      for p = 1, #pluginList do
         get_plugin_info(pluginList[p])
      end
   else
      printmsg("Downloading plugin list failed...Error " .. tostring(status))
   end
end

function get_plugin_info(plugin)
   local http_mode = string.sub(plugin.download, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   async.HEAD(plugin.download, async_head_plugin, http_mode, 120)
end

function install_plugin(plugin)
   --print("plugin.ids[1]: " .. plugin.ids[1])
   url = plugin.download
   local http_mode = string.sub(url, 1, 5)
   if http_mode == "https" then
      http_mode = string.upper(http_mode)
   else
      http_mode = "HTTP"
   end
   updatePlugin = plugin
   async.doAsyncRemoteRequest(url, async_plugin_download_complete, http_mode, 120)
end

function printmsg(msg)
   ColourNote("cornflowerblue", "", msg)
end

-- Changelog code courtesy of Durel
pluginId        = "1d1e01d90f0e2983c358b32e"

dbot = {}
----------------------------------------------------------------------------------------------------
-- dbot.version: Track the plugin's version and changelog and update the plugin 
--
-- dbot.version.changelog.get(minVersion, endTag)
-- dbot.version.changelog.getCR()
-- dbot.version.changelog.displayChanges(minVersion, changeLog)
-- dbot.version.changelog.displayChange(changeLogEntries)
--
-- dbot.version.update.release(mode, endTag)
-- dbot.version.update.releaseCR()
-- Note: dbot.version.update is derived from a plugin written by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

dbot.version               = {}

dbot.version.changelog     = {}
dbot.version.changelog.pkg = nil

dbot.version.update        = {}
dbot.version.update.pkg    = nil

drlDbotUpdateCheck         = "check"
drlDbotUpdateInstall       = "install"

drlDbotChangeLogTypeFix    = "@RFix@W"
drlDbotChangeLogTypeNew    = "@GNew@W"
drlDbotChangeLogTypeMisc   = "@yMsc@W"

function dbot.version.changelog.get(minVersion, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicCalendar/epiccalendar.changelog"
  local protocol = "HTTPS"

  if (dbot.version.changelog.pkg ~= nil) then
    Note("Skipping changelog request: another request is in progress")
  end -- if

  dbot.version.changelog.pkg            = {}
  dbot.version.changelog.pkg.url        = url
  dbot.version.changelog.pkg.protocol   = protocol
  dbot.version.changelog.pkg.minVersion = minVersion or 0
  dbot.version.changelog.pkg.endTag     = endTag
 
  dbot.version.changelog.getCR()
end -- dbot.version.changelog.get

function dbot.version.changelog.getCR()

  if (dbot.version.changelog.pkg == nil) then
    dbot.print("dbot.version.changelog.getCR: Change log package is missing!")
  end -- if

  local fileData = dbot.remote.get(dbot.version.changelog.pkg.url,
                                           dbot.version.changelog.pkg.protocol)
	if (fileData == nil) then
    dbot.print("@DNo changelog information was found. Please report to @CTallimos@D.")

  else
    loadstring(fileData)()
    if (dbot.changelog == nil) then
      dbot.print("dbot.version.changelog.getCR: Invalid changelog format detected")
    else
      dbot.version.changelog.displayChanges(dbot.version.changelog.pkg.minVersion, dbot.changelog)
    end -- if
  end -- if

  dbot.version.changelog.pkg = nil
end -- dbot.version.changelog.getCR

function dbot.version.changelog.displayChanges(minVersion, changeLog)
  local sortedLog = {}

  for k, v in pairs(changeLog) do
    table.insert(sortedLog, { version = tonumber(k) or 0, changes = v})
  end -- for
  table.sort(sortedLog, function (v1, v2) return v1.version < v2.version end)

  for _, clog in ipairs(sortedLog) do
    if (clog.version > minVersion) then
      dbot.version.changelog.displayChange(clog)
    end -- if
  end -- for

end -- dbot.version.changelog.displayChanges

-- Format of entry is: { version = 2.13,
--                       changes = { { change = drlDbotChangeLogTypeXYZ, desc = "what changed" }
--                                 }
--                     }
function dbot.version.changelog.displayChange(changeLogEntries)

  if (changeLogEntries == nil) then
    dbot.print("dbot.version.changelog.displayChange: Change entries are missing!")
    return
  end -- if

  dbot.print(string.format("@Cv%1.2f@W", changeLogEntries.version))
  for _, logEntry in ipairs(changeLogEntries.changes) do
    dbot.print(string.format("@W    (%s): %s", logEntry.change, logEntry.desc))
  end -- for
end -- dbot.version.changelog.displayChange

function dbot.version.update.release(mode, endTag)
  local url      = "https://raw.githubusercontent.com/tallimos/AardPlugins/main/EpicCalendar/Tallimos_EpicCalendar.xml"
  local protocol = "HTTPS"
  local retval   = DRL_RET_SUCCESS

  if (mode == nil) or ((mode ~= drlDbotUpdateCheck) and (mode ~= drlDbotUpdateInstall)) then
    dbot.print("dbot.version.update.release: Missing or invalid mode parameter")
  end -- if

  if (dbot.version.update.pkg ~= nil) then
    Note("Skipping update request: another update request is in progress")
  end -- if

  dbot.version.update.pkg          = {}
  dbot.version.update.pkg.mode     = mode
  dbot.version.update.pkg.url      = url
  dbot.version.update.pkg.protocol = protocol
  dbot.version.update.pkg.endTag   = endTag

	dbot.version.update.releaseCR()	
  return retval
end -- dbot.version.update.release

function dbot.version.update.releaseCR()

  if (dbot.version.update.pkg == nil) or (dbot.version.update.pkg.mode == nil) then
    dbot.error("dbot.version.update.releaseCR: Missing or invalid update package detected")
  end -- if

  local endTag = dbot.version.update.pkg.endTag

  -- This blocks until the plugin file is returned, an error is detected, or we time out
  local pluginData, retval = dbot.remote.get(dbot.version.update.pkg.url, dbot.version.update.pkg.protocol)
  if (retval ~= DRL_RET_SUCCESS) then
    dbot.print("dbot.version.update.releaseCR: Failed to retrieve latest plugin file: " ..
              dbot.retval.getString(retval))

  elseif (pluginData == nil) then
    dbot.print("@DCould not find a remote plugin release")
    retval = DRL_RET_MISSING_ENTRY

  else
    local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
    local currentVerStr  = string.format("%1.2f", currentVersion)
    local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
    local remoteVersion  = tonumber(remoteVerStr or "") or 0

    if (remoteVersion == currentVersion) then
      dbot.print("@DYou are running the latest version of the plugin (v@C" .. currentVerStr .. "@D)")

    elseif (remoteVersion < currentVersion) then
      dbot.print("@DYour current plugin (v@C" .. currentVerStr .. "@D) " ..
                "is newer than the latest official release (v@C" .. remoteVerStr .. "@D)")
      retval = DRL_RET_VER_MISMATCH

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateCheck) then
      dbot.print("@DYou are running v@C" .. currentVerStr .. "@D, latest version is v@C" .. remoteVerStr)
      dbot.print("@DChanges since your last update:")
      dbot.version.update.pkg = nil
      return dbot.version.changelog.get(currentVersion, endTag)

    elseif (dbot.version.update.pkg.mode == drlDbotUpdateInstall) then
      dbot.print("@DUpdating plugin from version @C" .. currentVerStr .. " @Dto version @C" .. remoteVerStr) 
      dbot.print("@DPlease wait until the update is complete.")

      local pluginFile = GetPluginInfo(GetPluginID(), 6)
      local file = io.open(pluginFile, "w")
      file:write(pluginData)
      file:close()
	  
	  dbot.reload()
    else
      dbot.print("@Ddbot.version.update.callback: Detected invalid mode \"@R" ..
                 (dbot.version.update.pkg.mode or "nil") .. "@W\"")
    end -- if

  end -- if

  dbot.version.update.pkg = nil

end -- dbot.version.update.releaseCR

----------------------------------------------------------------------------------------------------
-- Module to retrieve remote files
--
-- dbot.remote.get(url, protocol)
-- dbot.remote.getCR()
--
----------------------------------------------------------------------------------------------------

dbot.remote        = {}
dbot.remote.getPkg = nil

-- Blocks and then returns file, retval
-- Must be called from within a co-routine
function dbot.remote.get(url, protocol)
  local retval   = DRL_RET_SUCCESS
  local fileData = nil

  if (url == nil) or (url == "") then
    dbot.print("dbot.remote.get: missing url parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (protocol == nil) or (protocol == "") then
    dbot.print("dbot.remote.get: missing protocol parameter")
    return fileData, DRL_RET_INVALID_PARAMETER
  end -- if

  if (dbot.remote.getPkg ~= nil) then
    dbot.info("Skipping remote request: another request is in progress")
    return fileData, DRL_RET_BUSY
  end -- if

  dbot.remote.getPkg          = {}
  dbot.remote.getPkg.url      = url
  dbot.remote.getPkg.protocol = protocol
  dbot.remote.getPkg.isDone   = false

	dbot.remote.getCR()
  local timeout = 10
  local totTime = 0
  while (dbot.remote.getPkg.isDone == false) do
    if (totTime > timeout) then
      break
    end -- if
  end -- while

  if (dbot.remote.getPkg ~= nil) and (dbot.remote.getPkg.fileData ~= nil) then
    fileData = dbot.remote.getPkg.fileData
  else
    dbot.print("@DFailed to find data for file\n \"@C" .. url .. "@W\"")
  end -- if

  dbot.remote.getPkg = nil
  return fileData

end -- dbot.remote.get

function dbot.remote.getCR()
  if (dbot.remote.getPkg == nil) or (dbot.remote.getPkg.url == nil) then
    dbot.error("dbot.remote.getCR: remote package is nil or corrupted!")
    dbot.remote.getPkg = nil
    return 
  end -- if

  local urlThread = async.request(dbot.remote.getPkg.url, dbot.remote.getPkg.protocol)

  if (urlThread == nil) then
    dbot.print("dbot.remote.getCR: Failed to create thread requesting remote data")

  else
    local timeout = 10
    local totTime = 0
    while (urlThread:alive()) do
      if (totTime > timeout) then
        break
      end -- if
    end -- while

    local remoteRet, page, status, headers, fullStatus = urlThread:join()

    if (status ~= 200) then
      dbot.print("@DFailed to retrieve remote file")
    else
      dbot.remote.getPkg.fileData = page
    end -- if

    dbot.remote.getPkg.isDone = true

  end -- if
end -- dbot.remote.getCR

function dbot.print(string)
    AnsiNote(stylesToANSI(ColoursToStyles(string)))
end -- dbot.print

----------------------------------------------------------------------------------------------------
-- dbot.reload: Reloads the current plugin
--
-- Note: This code was derived from part of a plugin by Arcidayne.  Thanks Arcidayne!
----------------------------------------------------------------------------------------------------

function dbot.reload()
  local scriptPrefix = GetAlphaOption("script_prefix")
  local retval

  -- If the user has not already specified the script prefix for this version of mush, pick a
  -- reasonable default value
  if (scriptPrefix == "") then
    scriptPrefix = "\\\\\\"
    SetAlphaOption("script_prefix", scriptPrefix)
  end

  -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
  -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
  -- if it weren't installed? 
  retval = Execute(scriptPrefix.."DoAfterSpecial(1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
  if (retval ~= 0) then
    dbot.print("@Ddbot.reload: Failed to reload the plugin: mush error " .. retval)
  end -- if
end -- dbot.reload


]]>
</script> 
</muclient>
